<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 29 at column 182: CData section not finished

Android RunTime, ART
Linux Kernelê³¼ HALì ìì
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[Tech Note]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Tech Note</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 26 Jan 2026 07:55:32 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 26 Jan 2026 07:55:30 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Android]]></title><description><![CDATA[Android 관련 문서<a data-href="Android OS" href="2.-android/android-os/android-os.html" class="internal-link" target="_self" rel="noopener nofollow">Android OS</a>]]></description><link>2.-android/android.html</link><guid isPermaLink="false">2. Android/Android.md</guid><pubDate>Mon, 26 Jan 2026 07:54:46 GMT</pubDate></item><item><title><![CDATA[CS]]></title><description><![CDATA[Computer Science 관련 문서
운영체제
컴퓨터구조
<a data-href="네트워크" href="1.-cs/네트워크/네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크</a>
데이터베이스
자료구조
알고리즘
<br><a data-href="디자인패턴" href="1.-cs/디자인패턴/디자인패턴.html" class="internal-link" target="_self" rel="noopener nofollow">디자인패턴</a>
<br><a data-href="프로그래밍 패러다임" href="1.-cs/프로그래밍-패러다임/프로그래밍-패러다임.html" class="internal-link" target="_self" rel="noopener nofollow">프로그래밍 패러다임</a>
]]></description><link>1.-cs/cs.html</link><guid isPermaLink="false">1. CS/CS.md</guid><pubDate>Mon, 26 Jan 2026 07:54:30 GMT</pubDate></item><item><title><![CDATA[Android Compile]]></title><description><![CDATA[안드로이드의 최신 컴파일 방식은 ART(Android Runtime) 를 기반으로 하며, 단순히 한 가지 방식이 아니라 AOT, JIT, 그리고 클라우드 프로필이 정교하게 결합된 하이브리드 방식을 사용 앱 설치 단계
사용자가 앱을 설치할 때 ART는 전체 코드를 미리 컴파일하지 않음. 이에 앱 설치 속도가 매우 빠르고 설치 파일이 차지하는 초기 용량도 작게 유지됨. 앱 최초 실행 및 JIT 단계
앱을 실행하면 인터프리터가 바이트코드를 읽기 시작하며 필요한 부분을 실시간으로 컴파일하는 JIT 방식이 작동. 이때 시스템은 앱의 어느 부분이 자주 호출되는지 관찰하며 Hot Code라고 불리는 실행 데이터를 수집. 프로파일링 데이터 생성 단계
JIT 컴파일러가 실시간으로 코드를 번역하는 동안 기기 내부에 프로파일 정보가 기록됨. 이 정보에는 사용자가 앱에서 가장 많이 사용하는 기능과 자주 실행되는 메소드 경로가 담겨 있음. 유휴 상태 최적화 단계 (AOT 전환)
스마트폰을 사용하지 않고 충전 중인 유휴 상태가 되면 시스템은 백그라운드에서 최적화 작업을 시작. 앞서 수집된 프로파일 데이터를 기반으로 자주 사용되는 핵심 코드들만 골라내어 미리 기계어로 번역해 두는 AOT 컴파일을 수행. 최적화 이후의 실행 단계
이후 사용자가 다시 앱을 켰을 때 자주 쓰이는 핵심 기능들은 이미 기계어로 번역된 상태이므로 즉시 실행. 번역되지 않은 나머지 부분은 여전히 JIT 방식으로 처리하여 성능과 효율의 균형을 맞춤. 설치 시점에 모든 코드를 컴파일하지 않으므로 사용자는 앱 다운로드 후 기다리는 시간 없이 바로 앱을 실행할 수 있음.사용자가 실제로 자주 사용하는 기능 위주로 미리 컴파일되어 있기 때문에 앱의 로딩 속도와 부드러움이 비약적으로 향상.앱 전체를 무분별하게 미리 번역하지 않으므로 기기의 저장 공간을 절약할 수 있음. 또한 이미 번역된 코드를 실행할 때는 CPU 사용량이 줄어들어 배터리 소모를 낮추는 효과가 있음.사용자의 실제 앱 사용 패턴에 맞춰 시간이 지날수록 앱이 해당 사용자에게 가장 최적화된 상태로 변함.구글 플레이 스토어를 통해 성능을 극대화하는 방식입니다.수많은 사용자가 앱을 사용하며 생성된 "자주 쓰는 코드 데이터(Profile)"를 구글 서버에서 수집·통합
하여 새로운 사용자가 앱을 설치할 때, 통합된 클라우드 프로필을 함께 내려받음. 이에 앱을 처음 실행할 때부터 이미 최적화된 상태(AOT)로 동작하여 실행 속도가 비약적으로 빨라짐.개발자가 직접 제어할 수 있는 최신 최적화 도구.개발자가 앱의 핵심 경로(예: 앱 실행, 목록 스크롤)를 미리 프로파일링하여 APK/AAB에 포함하여
사용자는 앱을 처음 설치하자마자 클라우드 데이터 없이도 주요 기능을 최고 성능으로 사용할 수 있음.]]></description><link>2.-android/android-os/android-compile.html</link><guid isPermaLink="false">2. Android/Android OS/Android Compile.md</guid><pubDate>Mon, 26 Jan 2026 07:53:14 GMT</pubDate></item><item><title><![CDATA[Android RunTime]]></title><description/></item><item><title><![CDATA[프로그래밍 패러다임]]></title><description><![CDATA[Programming Paradigm
프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
프로그래밍 패러다임
<a data-tooltip-position="top" aria-label="선언형 프로그래밍" data-href="선언형 프로그래밍" href="1.-cs/프로그래밍-패러다임/선언형-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">선언형</a> <br><a data-tooltip-position="top" aria-label="선언형 프로그래밍 > 함수형 프로그래밍" data-href="선언형 프로그래밍#함수형 프로그래밍" href="1.-cs/프로그래밍-패러다임/선언형-프로그래밍.html#함수형 프로그래밍" class="internal-link" target="_self" rel="noopener nofollow">함수형</a> 명형형 <br><a data-tooltip-position="top" aria-label="객체지향 프로그래밍" data-href="객체지향 프로그래밍" href="1.-cs/프로그래밍-패러다임/객체지향-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">객체지향형</a>
<br><a data-tooltip-position="top" aria-label="절차지향 프로그래밍" data-href="절차지향 프로그래밍" href="1.-cs/프로그래밍-패러다임/절차지향-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">절차지향형</a> 프로그래밍 기법, 개발 방법론의 정답은 없다.
비즈니스 로직 및 서비스 특징을 고려해 패러다임을 결정하는 것이 중요.]]></description><link>1.-cs/프로그래밍-패러다임/프로그래밍-패러다임.html</link><guid isPermaLink="false">1. CS/프로그래밍 패러다임/프로그래밍 패러다임.md</guid><pubDate>Mon, 19 Jan 2026 13:33:06 GMT</pubDate></item><item><title><![CDATA[Welcome]]></title><description><![CDATA[Tuan(이정훈)이 작성한 개발 관련 지식 아카이브입니다.CS(Computer Science), Mobile 관련이 주를 이룹니다.
Architecture, Back-End 관련 내용도 추후 천천히 업로드 예정입니다.해당 아카이브는 PC 환경에 최적화되어 있습니다.
아직 정보 인덱스 관리가 미흡합니다.
원하는 정보를 찾는 경우 검색 또는 목차에서 탐색 부탁드립니다.CS
Android
Document<a data-tooltip-position="top" aria-label="mailto:jhmh0226@gmail.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:jhmh0226@gmail.com" target="_self">jhmh0226@gmail.com</a>
오류 관련 지적 환영합니다.]]></description><link>welcome.html</link><guid isPermaLink="false">Welcome.md</guid><pubDate>Sun, 18 Jan 2026 21:43:41 GMT</pubDate></item><item><title><![CDATA[디자인패턴]]></title><description><![CDATA[
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 정해놓은 규약
<a data-href="싱글톤 패턴(Singleton Pattern)" href="1.-cs/디자인패턴/싱글톤-패턴(singleton-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">싱글톤 패턴(Singleton Pattern)</a><br><a data-href="팩토리 패턴(Factory Pattern)" href="1.-cs/디자인패턴/팩토리-패턴(factory-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">팩토리 패턴(Factory Pattern)</a><br><a data-href="옵저버 패턴(Observer Pattern)" href="1.-cs/디자인패턴/옵저버-패턴(observer-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">옵저버 패턴(Observer Pattern)</a><br><a data-href="프록시 패턴(Proxy Pattern)" href="1.-cs/디자인패턴/프록시-패턴(proxy-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">프록시 패턴(Proxy Pattern)</a><br><a data-href="이터레이터 패턴(iterator Pattern)" href="1.-cs/디자인패턴/이터레이터-패턴(iterator-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">이터레이터 패턴(iterator Pattern)</a><br><a data-href="전략 패턴(Straegy Pattern)" href="1.-cs/디자인패턴/전략-패턴(straegy-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">전략 패턴(Straegy Pattern)</a><br><a data-href="노출모듈 패턴(Revealing Module Pattern)" href="1.-cs/디자인패턴/노출모듈-패턴(revealing-module-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">노출모듈 패턴(Revealing Module Pattern)</a><br><a data-href="MVC 패턴" href="1.-cs/디자인패턴/mvc-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVC 패턴</a><br><a data-href="MVP 패턴" href="1.-cs/디자인패턴/mvp-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVP 패턴</a><br><a data-href="MVP 패턴" href="1.-cs/디자인패턴/mvp-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVP 패턴</a>]]></description><link>1.-cs/디자인패턴/디자인패턴.html</link><guid isPermaLink="false">1. CS/디자인패턴/디자인패턴.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[네트워크]]></title><description><![CDATA[
컴퓨터 등의 장치들이 통신 기술을 이용하여 구축하는 연결망
노드(node) + 링크(link)로 연결되어 있으며, 리소스를 공유하는 집합
노드 : 서버, 라우터, 스위치 등 네트워크 장비
링크 : 유선 또는 무선좋은 네트워크란 많은 <a data-tooltip-position="top" aria-label="처리량과 지연 시간 > 처리량" data-href="처리량과 지연 시간#처리량" href="1.-cs/네트워크/처리량과-지연-시간.html#처리량" class="internal-link" target="_self" rel="noopener nofollow">처리량</a>을 처리할 수 있으며 <a data-tooltip-position="top" aria-label="처리량과 지연 시간 > 지연 시간" data-href="처리량과 지연 시간#지연 시간" href="1.-cs/네트워크/처리량과-지연-시간.html#지연 시간" class="internal-link" target="_self" rel="noopener nofollow">지연 시간</a>이 짧고 장애 빈도가 적은 네트워크<br><a data-href="네트워크 분류" href="1.-cs/네트워크/네트워크-분류.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 분류</a><br><a data-href="네트워크 토폴로지" href="1.-cs/네트워크/네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 토폴로지</a><br><a data-href="네트워크 성능 분석 명령어" href="1.-cs/네트워크/네트워크-성능-분석-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 성능 분석 명령어</a><br><a data-href="네트워크 기기" href="1.-cs/네트워크/네트워크-기기.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 기기</a><br><a data-href="IP 주소 체계" href="1.-cs/네트워크/ip-주소-체계.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소 체계</a><br><a data-href="ARP" href="1.-cs/네트워크/arp.html" class="internal-link" target="_self" rel="noopener nofollow">ARP</a><br><a data-href="홉바이홉 통신" href="1.-cs/네트워크/홉바이홉-통신.html" class="internal-link" target="_self" rel="noopener nofollow">홉바이홉 통신</a>
Internet Protocol Suite
인터넷에서 컴퓨터들이 서로 정보를 주고 받는 데 사용되는 프로토콜의 집합
<br>일반적으로 <a data-href="TCP／IP 4계층" href="1.-cs/네트워크/tcp／ip-4계층.html" class="internal-link" target="_self" rel="noopener nofollow">TCP／IP 4계층</a> 모델이나 <a data-href="OSI 7계층" href="1.-cs/네트워크/osi-7계층.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 7계층</a> 모델로 설명한다.]]></description><link>1.-cs/네트워크/네트워크.html</link><guid isPermaLink="false">1. CS/네트워크/네트워크.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[README]]></title><description><![CDATA[Tuan(이정훈)이 작성한 개발 관련 지식 아카이브입니다.CS(Computer Science), Mobile 관련이 주를 이룹니다.
Architecture, Back-End 관련 내용도 추후 천천히 업로드 예정입니다.아직 정보 인덱스 관리가 미흡합니다.
원하는 정보를 찾는 경우 검색 또는 목차에서 탐색 부탁드립니다.CS
Android
Document<a data-tooltip-position="top" aria-label="mailto:jhmh0226@gmail.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:jhmh0226@gmail.com" target="_self">jhmh0226@gmail.com</a>
오류 관련 지적 환영합니다.]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Sun, 18 Jan 2026 21:11:40 GMT</pubDate></item><item><title><![CDATA[어노테이션]]></title><description><![CDATA[
JDK 1.5부터 추가
자바 또는 코틀린 소스코드에 추가하는 메타데이터
컴파일러에세 부가정보 제공
클래스 필드, 메서드 및 기타 요소에서 선택적으로 선언 가능
런타임에서도 참조 가능
컴파일 타임에 어노테이션을 스캔하고, 소스코드를 검사 또는 생성한다.<img alt="Hilt_annotation.svg" src="99.-이미지/android/hilt_annotation.svg" target="_self">class UnscopedBinding @Inject constructor(){} 매 요청 시 새로운 인스턴스를 생성
@FragmentScoped
class ScopedBinding @Inject constructor(){} 스코프 어노테이션이 있으므로, 해당 Hilt 컴포넌트의 수명동안은 매 요청에 동일한 인스턴스 반환을 보장
@Module
@InstallIn(FragmentComponent::class)
object FooModule{ // 스코프 없음 @Provides fun provideUnscopedBinding() = UnscopedBinding() // 스코프 있음 @Provides @FragmentScoped fun provideScopedBinding() = ScopedBinding() } 어떤 의존성을 인스턴스화하는 비용이 클 때
동일한 인스턴스 반환을 원할 때
특정 인스턴스를 공유하고 싶을 때
Scope Annotation을 사용한다. Hilt 어노테이션을 사용하여 부가정보를 제공
컴파일 타임에 의존성 그래프에 이상이 없는지 확인
생성된 소스코드를 기반으로 동작하므로 리플렉션을 사용하지 않아도 됨
]]></description><link>2.-android/의존성주입/어노테이션.html</link><guid isPermaLink="false">2. Android/의존성주입/어노테이션.md</guid><pubDate>Sun, 18 Jan 2026 20:55:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Hilt_annotation]]></title><description><![CDATA[<img src="99.-이미지/android/hilt_annotation.svg" target="_self">]]></description><link>99.-이미지/android/hilt_annotation.html</link><guid isPermaLink="false">99. 이미지/Android/Hilt_annotation.svg</guid><pubDate>Sun, 18 Jan 2026 20:45:01 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[무제 파일]]></title><description><![CDATA[@HiltAndroidAppSingletonComponent == container컴파일 타임에 SingletonComponent에 의존성을 추가 할 수 있음.
(Provide annotation, 생성자 바인딩)바인딩 : component에 의존성을 추가하는 것@AndroidEntryPointActivityRetainedCompontent]]></description><link>2.-android/의존성주입/무제-파일.html</link><guid isPermaLink="false">2. Android/의존성주입/무제 파일.md</guid><pubDate>Sun, 18 Jan 2026 20:43:33 GMT</pubDate></item><item><title><![CDATA[바이트 코드 변조]]></title><description><![CDATA[자바 소스코드가 컴파일을 거쳐 나온 결과물
자바 소스 코드(.java) -&gt; 자바 컴파일러 -&gt; 자바 바이트 코드(.class)
AGP(Android Gragle Plugin)에 포함된 API
중간 빌드 산출물들을 처리
바이트 코드 변환을 위한 Gradle Task 생성
AGP는 변조된 내용들 사이의 의존성을 핸들링
소스코드 -&gt; 컴파일러 -&gt; 바이트 코드 -&gt; D8 -&gt; Dex -&gt; APK/AAB소스코드 -&gt; 컴파일러 -&gt; 바이트 코드 -&gt; 바이트 코드 변조 -&gt; D8 -&gt; Dex -&gt; APK/AAB@HiltAndroidApp
public class App extends Application()
App -&gt; 컴파일러 -&gt; Hilt_AppHilt 어노테이션이 포함된 소스코드 -&gt; 어노테이션 프로세싱 -&gt; 생성된 소스코드 -&gt; 컴파일 -&gt; 바이트코드 산출 -&gt; 바이트코드 변조 -&gt; D8 컴파일 -&gt; APK/AAB 패키징
어노테이션은 메타데이터를 제공
어노테이션 프로세서는 메타데이터를 읽고 소스코드를 생성한다.
생성된 소스코드로 인해 보일러플레이트 감소
AGP에 포함된 Transform API로 바이트코드를 변조
Dagger(Hilt)로 생성된 소스코드는 바이트코드 변조 과정을 통해 자동으로 프로젝트에 적용
]]></description><link>2.-android/의존성주입/바이트-코드-변조.html</link><guid isPermaLink="false">2. Android/의존성주입/바이트 코드 변조.md</guid><pubDate>Sun, 18 Jan 2026 20:43:33 GMT</pubDate></item><item><title><![CDATA[DI(Dependency Injection)]]></title><description><![CDATA[의존성 : 어떤 대상이 참조하는 객체(또는 함수): 대상 객체(client)에 의존성을 제공하는 기술
의존성을 파라미터로 받으면 클래스는 의존성 생성에 대한 책임이 없다.
IoC(제어의 역전)
의존성 주입의 장점
재사용성 : 클래스의 소스코드를 변경하지 않아도 된다.
디커플링 : 결합도를 느슨하게 만들어 준다.
단일 책임 원칙 : 하나의 기능만을 책임질 수 있도록 완전히 캡슐화하는 것
--&gt; 기능에 집중할 수 있음 --&gt; 개발과 유지보수가 용이Injector : 의존성을 클라이언트에게 제공하는 역할
(Container, Assembler, Provider, Factory)
클래스간 결합도를 낮춤
재사용 가능
보일러 플레이트 감서
테스트 용이
의존성 관리 용이(자원 공유)
]]></description><link>2.-android/의존성주입/di(dependency-injection).html</link><guid isPermaLink="false">2. Android/의존성주입/DI(Dependency Injection).md</guid><pubDate>Sun, 18 Jan 2026 20:43:33 GMT</pubDate></item><item><title><![CDATA[Hilt]]></title><description><![CDATA[: 안드로이드를 위한 표준적인 DI 솔루션을 제공하는 라이브러리
어노테이션 프로세서로 자동 코드 생성
Hilt 이전 인기 라이브러리
가파른 학습 곡선
높은 자유도 안드로이드를 위한 확실한 방향성 제시
간단한 설정 및 사용방법
비즈니스 로직에 집중 Dagger2를 기반으로 안드로이드를 위한 표준화된 의존성 주입 방법 제공
보일러플레이트 감소
Jetpack과 통합
테스트 도구 제공
마이그레이션 API 제공
표준 컴포넌트 제공 --&gt; 정해진 방법대로 의존성주입ViewModel.Factory 확장 필요 없음
별도 컴포넌트 정의 불필요implementation 'com.google.dagger:hilt-android:version'
kotlin : kapt 'com.google.dagger:hilt-compiler:$version'// 장치 테스트 용
androidTestImplementation 'com.google.dagger:hilt-testing:version'// 로컬 유닛 테스트 용
testImplementation 'com.google.dagger:hilt-testing:version'kapt {
correctErrorTypes = true
}@HiltAnnotation 소스코드.kt -&gt; KAPT -&gt; Stub.java -&gt; 자바 컴파일러// 프로젝트 루트 build.gradle
plugins {
id 'com.google.dagger.hilt.android' version $version apply false
}// 안드로이드 모듈별 build.gradle
plugins {
id 'com.android.application'
id 'com.google.dagger.hilt.android'
id 'kotlin-kapt'
}
바이트코드 변조를 통해서 개발자들에게 편의성을 제공하기 위함.
]]></description><link>2.-android/의존성주입/hilt.html</link><guid isPermaLink="false">2. Android/의존성주입/Hilt.md</guid><pubDate>Sun, 18 Jan 2026 20:43:33 GMT</pubDate></item><item><title><![CDATA[유스케이스 문서와 구현되는 코드에 대해]]></title><description><![CDATA[
유스케이스 문서에는 코드의 모든 세부가 담길 필요는 없지만, 문서에 정의된 비즈니스 규칙과 흐름은 코드에서 반드시 구현되어야 한다.
즉, 유스케이스 문서에 코드로 작성되어야하는 모든 것이 명세되어 있지 않아도 된다. 단, 코드에는 유스케이스 명세서에 작성된 모든 내용이 포함되어야 한다.]]></description><link>4.-document/유스케이스-문서와-구현되는-코드에-대해.html</link><guid isPermaLink="false">4. Document/유스케이스 문서와 구현되는 코드에 대해.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[정규화]]></title><description><![CDATA[
릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정.
다음과 같은 릴레이션을 만족하는 것을 목표로 함.
같은 의미를 표현하는 릴레이션이지만 좋은 구조로 만들어야함.
자료의 중복성은 감소해야함.
독립적인 관계는 별개의 릴레이션으로 표현해야함.
각각의 릴레이션은 독립적인 표현이 가능해야함.
릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성.
기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됨.<img alt="데이터베이스_제1정규화.png" src="99.-이미지/cs/데이터베이스_제1정규화.png" target="_self">릴레이션이 제1정규형이며 부분 함수의 종속성을 제가한 형태.
기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적.<br><img alt="데이터베이스_제2정규형.png" src="99.-이미지/cs/데이터베이스_제2정규형.png" target="_self">릴레이션을 분할할 때 동등한 릴레이션으로 분해해야함.
정보 손실이 발생하지 않는 무손실 분해로 분해되어야함.제2정규형임을 만족하면서 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태<br><img alt="데이터베이스_제3정규형.png" src="99.-이미지/cs/데이터베이스_제3정규형.png" target="_self">A -&gt; B, B -&gt; C이면, A -&gt; C가 성립하는데, 이때 C가 A에 이행적으로 함수 종속되었다고 함.제3정규형을 만족하고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태.결정자
함수 종속 관계에서 특정 종속자를 결정짓는 요소
X -&gt; Y일 때 X는 결정자, Y는 종속자
보통 여기 까지만 진행하고 진행하지 않음.
그 이유는 정규화가 너무 많이 진행될 경우&nbsp;
엔터티 증가
엔터티 사이의 관계가 증가
데이터 조회시 조인이 늘어나, 조회 성능이 하락
등의 문제가 발생하기에 보통 제3 정규형까지만 진행.보이스 코드 정규화를 만족하는 릴레이션에 대해, 다치 종속을 제거하는 것제4정규화를 만족하는 릴레이션에 대해, 조인 종속을 제거하는 것]]></description><link>1.-cs/데이터베이스/정규화.html</link><guid isPermaLink="false">1. CS/데이터베이스/정규화.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[조인]]></title><description><![CDATA[
Join
하나의 테이블이 아닌 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것
Inner Join
왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기SELECT * FROM TableA
INNER JOIN TableB ON
A.key = B.key
두 테이블 간에 교집합을 의미Left Outer Join
왼쪽 테이블의 모든 행이 결과 테이블에 표기SELECT * FROM TableA
LEFT JOIN TableB ON
A.key = B.key
Right Outer Join
오른쪽 테이블의 모든 행이 결과 테이블에 표기SELECT * FROM TableA
RIGHT JOIN TableB ON
A.key = B.key
Full Outer Join
두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기SELECT * FROM TableA
FULL OUTER JOIN TableB ON
A.key = B.key
NLJ, Nested Loop Join
중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법.
핸던 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음.
-&gt; 2차원 배열의 순차 조회와 유사한 구조,
-&gt; 조인할 테이블을 작은 블록으로 나눠 하나씩 조인하는 Block Nested Loop 방식 존재함.각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후 조인 작업을 수행하는 방법.
적절한 인덱스가 없고 대용량의 테이블들을 조인하는 경우, 조인 조건으로 범위 비교 연산자가 존재하는 경우 사용함.해시 테이블을 기반으로 조인하는 방법.Build Phase
입력 테이블 중 하나를 기반으로 메모리 내에 해시 테이블을 생성하는 단계.Probe Phase
해시 테이블을 생성하지 않은 나머지 테이블을 기준으로, 순차적으로 순회하며 해시 테이블과 일치하는 레코드를 찾아 결괏값을 도출.각 테이블은 한번씩만 읽기 때문에 NLJ에 비해 성능이 좋음.]]></description><link>1.-cs/데이터베이스/조인.html</link><guid isPermaLink="false">1. CS/데이터베이스/조인.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[트랜잭션]]></title><description><![CDATA[
데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위.
여러 개의 쿼리들을 하나로 묶는 단위.
원자성, 일관성, 독립성, 지속성.
ACID
Atomicity
트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징.
트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장.
ALL OR NOTHINGCommit
여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것Rollback
트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 되돌리는 것트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안됨.
만약 있다면 롤백이 일어났을 때에 대한 예외 처리가 필요함.
-&gt; 트랜잭션 전파를 신경써서 관리 해야함.트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨 수행해야함.
이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메소드의 호출을 하나의 트랜잭션에 묶는 것Consistency
허용된 방식으로만 데이터를 변경해야 하는 것
트랜잭션 실행 후에도 데이터베이스의 상태가 유효해야함.
즉, 트랜잭션 실핼 후에도 데이터베이스의 제약이나 규칙을 만족하여야함.Isolation
트랜잭션 수행 시 서로 끼어들지 못하는 것
복수의 병렬 트랜잭션은 거로 격리되어 순차적으로 실행되는 것처럼 작동되어야함.
여러 개의 격리 수준으로 나누어 격리성을 보장함.<img alt="격리성.png" src="99.-이미지/cs/격리성.png" target="_self">Phantom Read
트랜잭션 내에서 같은 조건으로 데이터를 조회했을 때, 없던 레코드가 새로 나타나는(유령) 현상
한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우.Non-Repeatable Read
한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데 그 결과가 다른 현상
행 값이 달라질 수 있음.
팬텀 리드는 다른 행이 선택될 수 있는 점이 상이함.Dirty Read
다른 트랜잭션이 수정한 후 아직 커밋(Commit)하지 않은 데이터를 읽는 현상
한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있는 경우. 트랜잭션을 순차적으로 실행.
여러 트랜잭션이 동시에 같은 행에 접근할 수 없음.
가장 엄격한 수주으로 해당 행을 격리시키고, 이후 행에 대한 접근이 일어난다면 기다려야함.
교착 상태가 일어날 확률이 높고 가장 성능이 떨어짐.하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌.
새로운 행을 추가하는 것은 막지 않음.다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음.
커밋이 완료된 데이터에 대해서만 조회를 허용.
트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음.
-&gt; 반복 가능하지 않은 조회가 발생할 수 있음.가장 낮은 격리 수준.
하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출됨.Durability
성송적으로 수행된 트랜잭션은 영원히 반영되는 특징
데이터베이스 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야함.
체크섬, 저널링, 롤백 등의 기능 제공중복 검사의 한 형태, 오류 정정을 통해 송신된 자료의 무결성을 보호.변경 사항을 커밋 전에 로깅(logging)하는 것.
트랜잭션 등 변경 사항에 대한 로그를 남기는 것.]]></description><link>1.-cs/데이터베이스/트랜잭션.html</link><guid isPermaLink="false">1. CS/데이터베이스/트랜잭션.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스]]></title><description><![CDATA[
DataBase
일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음.
DataBase Management System, 데이터베이스 제어, 관리 통합 시스템.
쿼리를 통해 삽입, 삭제, 수정, 조회가 가능.
데이터베이스와 실시간 접근과 동시 공유가 가능.위와 같은 구조를 기반으로 데이터를 주고 받음.RDBMS
행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터 베이스
MySQL, PostgreSQL,오라클, SQL Server, MSSQL 등SQL을 사용하지 않는 데이터베이스<img alt="데이터베이스_용어.png" src="99.-이미지/cs/데이터베이스_용어.png" target="_self">Entity
여러 개의 속성을 지닌 명사.
서비스 요구사항에 맞춰 속성이 정해짐.Relation
데이터베이스에서 정보를 구분하여 저장하는 기본 단위.
엔티티에 관한 데이터를 하나의 릴레이션에 담아서 관리.Attribute
릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보.Tuple
릴레이션을 구성하는 각 행으로, 속성들의 값으로 구성된 하나의 정보 단위.Domain
하나의 속성이 가질 수 있는 원자 값들의 집합.Field
실제 물리적인 저장 공간에서 데이터가 기록되는 최소 단위의 항목.Record
물리적인 데이터 파일 내에서 연관된 필드들이 모여 구성된 하나의 데이터 단위.Schema
데이터베이스의 구조와 제약 조건에 관해 전반적인 명세를 정의한 것.하나의 레코드가 다른 테이블의 레코드 한 개와만 연결된 경우<br><img alt="데이터베이스_1대1.png" src="99.-이미지/cs/데이터베이스_1대1.png" target="_self">하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우<br><img alt="데이터베이스_1대N.png" src="99.-이미지/cs/데이터베이스_1대n.png" target="_self">여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우<br><img alt="데이터베이스_N대M.png" src="99.-이미지/cs/데이터베이스_n대m.png" target="_self">테이블 간의 관계를 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치.
조건에 맞는 튜플을 찾거나, 레코드 간의 고유성을 식별하고 테이블 간의 관계를 맺기 위해 사용하는 중요한 도구<br><img alt="데이터베이스_키.png" src="99.-이미지/cs/데이터베이스_키.png" target="_self">Primary Key, PK
유일성과 최소성을 만족하는 키.
자연키 또는 인조키 중에 골라 설정함.비즈니스 모델에서 이미 존재하는 속성 중에서 기본키로 사용할 수 있는 속성.
속성 중 기본키를 선택하기 위해 중복된 값들을 제외하며 중복되지 않는 것을 자연스레 뽑다가 나오는 키원래 데이터에는 없지만, 오직 식별을 목적으로 새롭게 부여한 키Foreign Key, FK
다른 테이블의 기본키를 그대로 참조하는 값. 개체와의 관계를 식별하는 데 사용Candidate Key
기본키가 될 수 있는 후보들. 유일성과 최소성을 동시에 만족하는 키Alternate Key
후보키가 두개 이상이 경우 기본키로 지정한 키를 제외하고 남은 후보키Super Key
각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키]]></description><link>1.-cs/데이터베이스/데이터베이스.html</link><guid isPermaLink="false">1. CS/데이터베이스/데이터베이스.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[무결성]]></title><description><![CDATA[
데이터의 정확성, 일관성, 유효성을 유지하는 것
무결성이 유지되어야 데이터베이스에 저장된 데이터 값에 대한 신뢰가 생김.기본키로 선택된 필드는 빈 값을 허용하지 않음.서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야함.특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 해당 속성 값은 모두 고유한 값임.특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 해당 속성 값은 NULL이 될 수 없음.]]></description><link>1.-cs/데이터베이스/무결성.html</link><guid isPermaLink="false">1. CS/데이터베이스/무결성.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[인덱스]]></title><description><![CDATA[
데이터를 빠르게 찾을 수 있는 하나의 장치
릴레이션에 있는 데이터를 빠르게 찾기 위해 색인을 만들어 관리하는 별도의 데이터 구조
책의 맨 뒤에 있는 찾아보기와 같은 역할을 함.인덱스가 없다면 데이터베이스는 특정 데이터를 찾기 위해 테이블의 처음부터 끝까지 모든 행을 읽어야 하는 Full Table Scan을 수행함. 인덱스를 생성하면 특정 기준에 따라 정렬된 리스트를 통해 데이터가 저장된 물리적 위치로 즉시 이동할 수 있음.가장 보편적인 인덱스 구조로, 데이터를 정렬된 상태로 유지하며 루트 노드에서 리프 노드까지의 탐색 거리가 일정하여 일관된 성능을 보장키 값을 해시 함수에 넣어 데이터의 위치를 찾는 방식
값의 일치 여부 확인에는 매우 빠르지만, 크다/작다와 같은 범위 검색에는 사용할 수 없음SELECT 문을 사용한 데이터 검색 성능이 비약적으로 상승함.시스템 부하 감소 전체 데이터를 읽는 빈도가 줄어들어 CPU와 메모리 자원을 효율적으로 사용함.인덱스 자체를 관리하기 위해 테이블 크기의 약 10%에 해당하는 별도의 저장 공간이 필요데이터의 삽입, 수정, 삭제가 일어날 때마다 인덱스 정보를 다시 계산하고 정렬해야 하므로 쓰기 작업 속도가 느려집니다.카디널리티 값의 종류가 많고 중복도가 낮은 컬럼일수록 인덱스 효율이 극대화됨.활용 빈도 WHERE 절이나 JOIN, ORDER BY 절에 자주 사용되는 컬럼을 인덱스 대상으로 선정 해야함.Clustered Index
데이터 자체가 인덱스의 순서에 따라 물리적으로 정렬되어 저장되는 방식
영어 사전처럼 데이터가 곧 인덱스인 형태이며, 테이블당 단 하나만 존재할 수 있음.Non-Clustered Index
데이터 자체는 정렬되지 않은 채로 두고, 별도의 공간에 인덱스와 실제 주소를 기록하는 방식
책의 찾아보기와 같으며, 한 테이블에 여러 개를 만들 수 있음.]]></description><link>1.-cs/데이터베이스/인덱스.html</link><guid isPermaLink="false">1. CS/데이터베이스/인덱스.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[ERD]]></title><description><![CDATA[
Entity Relationship Diagram
릴레이션 간의 관계를 도식화한 다이어그램
데이터베이스를 구축할 때 가장 기초적인 뼈대 역할
ERD는 시스템의 요구사항을 기반으로 작성되며 해당 ERD를 기반으로 데이터베이스를 구축함.
디버깅 또는 재설계가 필요한 경우에도 설계도 역할을 담당.관계형 데이터베이스를 표현하는 것은 유용하나, 비정형 데이터를 표현이 불가능함.]]></description><link>1.-cs/데이터베이스/erd.html</link><guid isPermaLink="false">1. CS/데이터베이스/ERD.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[프록시 패턴(Proxy Pattern)]]></title><description><![CDATA[
대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링, 수정하는 등의 역할을 하는 계층이 존재하는 디자인 패턴
some-where &lt;-&gt; interface &lt;-&gt; proxy &lt;-&gt; interface &lt;-&gt; subject
객체의 속성, 변환 등을 보완.
보안, 데이터 검증, 캐싱, 로깅
프록시 서버
]]></description><link>1.-cs/디자인패턴/프록시-패턴(proxy-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/프록시 패턴(Proxy Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[디자인패턴]]></title><description><![CDATA[
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 정해놓은 규약
<a data-href="싱글톤 패턴(Singleton Pattern)" href="1.-cs/디자인패턴/싱글톤-패턴(singleton-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">싱글톤 패턴(Singleton Pattern)</a><br><a data-href="팩토리 패턴(Factory Pattern)" href="1.-cs/디자인패턴/팩토리-패턴(factory-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">팩토리 패턴(Factory Pattern)</a><br><a data-href="옵저버 패턴(Observer Pattern)" href="1.-cs/디자인패턴/옵저버-패턴(observer-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">옵저버 패턴(Observer Pattern)</a><br><a data-href="프록시 패턴(Proxy Pattern)" href="1.-cs/디자인패턴/프록시-패턴(proxy-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">프록시 패턴(Proxy Pattern)</a><br><a data-href="이터레이터 패턴(iterator Pattern)" href="1.-cs/디자인패턴/이터레이터-패턴(iterator-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">이터레이터 패턴(iterator Pattern)</a><br><a data-href="전략 패턴(Straegy Pattern)" href="1.-cs/디자인패턴/전략-패턴(straegy-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">전략 패턴(Straegy Pattern)</a><br><a data-href="노출모듈 패턴(Revealing Module Pattern)" href="1.-cs/디자인패턴/노출모듈-패턴(revealing-module-pattern).html" class="internal-link" target="_self" rel="noopener nofollow">노출모듈 패턴(Revealing Module Pattern)</a><br><a data-href="MVC 패턴" href="1.-cs/디자인패턴/mvc-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVC 패턴</a><br><a data-href="MVP 패턴" href="1.-cs/디자인패턴/mvp-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVP 패턴</a><br><a data-href="MVP 패턴" href="1.-cs/디자인패턴/mvp-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">MVP 패턴</a>]]></description><link>1.-cs/디자인패턴.html</link><guid isPermaLink="false">1. CS/디자인패턴.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[이터레이터 패턴(iterator Pattern)]]></title><description><![CDATA[
iterator를 사용하여 collection의 요소들에 접근하는 디자인 패턴
순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터는 하나의 인터페이스로 순회 가능iterator protocol : 이터러블한 객체들을 순회할 때 사용되는 규칙
iterable subject : 반복 가능한 객체로 일반화한 객체]]></description><link>1.-cs/디자인패턴/이터레이터-패턴(iterator-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/이터레이터 패턴(iterator Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[전략 패턴(Straegy Pattern)]]></title><description><![CDATA[
객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체를 가능케하는 패턴
]]></description><link>1.-cs/디자인패턴/전략-패턴(straegy-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/전략 패턴(Straegy Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[팩토리 패턴(Factory Pattern)]]></title><description><![CDATA[
객체 생성 부분을 추상화한 패턴
상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정, 하위 클래스에 객체 생성에 관한 구체적인 내용을 정하는 구조.상위 클래스와 하위 클래스가 분리되어 있기 때문에 결합성이 낮음.
상위 클래스에서는 인스턴스 생성 방식에 대해 고려하지 않아도 되어 유연성 증가.
객체 생성 로직이 별도이기 때문에 유지 보수성 증가
]]></description><link>1.-cs/디자인패턴/팩토리-패턴(factory-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/팩토리 패턴(Factory Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[노출모듈 패턴(Revealing Module Pattern)]]></title><description><![CDATA[
즉시 실행 함수를 통해 접근 제어자를 만드는 패턴
]]></description><link>1.-cs/디자인패턴/노출모듈-패턴(revealing-module-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/노출모듈 패턴(Revealing Module Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[싱글톤 패턴(Singleton Pattern)]]></title><description><![CDATA[
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
일반적으로 하나의 클래스를 기반으로 여러 개의 개별적인 인스턴스를 만들어 사용.싱글톤 패턴은 하나의 크래스를 기반으로 단 하나의 인스턴스 만을 만들어 해당 인스턴스를 기반으로 로직을 만드는 데 사용.
ex) 데이터베이스 연결 모듈생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나.
최초 생성 이후에 호출된 최초의 생성자가 생성한 객체를 반환.즉. 클래스 내부에서 인스턴스를 관리하고, 생성자 내부에 인스턴스 보유 여부에따라 기존 객체 반환 또는 객체 생성을 결정.
인스턴스 생성 비용 감소 의존성 증가 모듈 간의 결합도가 증가 -&gt; DI로 해결 가능 TDD의 걸림돌 테스트 마다 독립적인 인스턴스 생성이 힘듦 ]]></description><link>1.-cs/디자인패턴/싱글톤-패턴(singleton-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/싱글톤 패턴(Singleton Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[옵저버 패턴(Observer Pattern)]]></title><description><![CDATA[
객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
subject : 관찰을 당하는 객체
주체 : subject의 상태 변화를 보고 있는 관찰자
옵저버: subject의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 발생하는 객체]]></description><link>1.-cs/디자인패턴/옵저버-패턴(observer-pattern).html</link><guid isPermaLink="false">1. CS/디자인패턴/옵저버 패턴(Observer Pattern).md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[MVVM 패턴]]></title><description><![CDATA[
뷰, 뷰모델, 모델로 구성된 패턴
뷰모델을 통해 뷰를 더욱 추상화함.
MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 지원.
뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원.
-&gt; 데이터 바인딩을 지원하지만 철학적으로 추구하는 방향은 아님.
-&gt; 보통 MVVM과 Clean Architecture를 같이 사용하는 경우 단방향 데이터 흐름을 추구단위 테스트에 용이]]></description><link>1.-cs/디자인패턴/mvvm-패턴.html</link><guid isPermaLink="false">1. CS/디자인패턴/MVVM 패턴.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[MVC 패턴]]></title><description><![CDATA[
모델, 뷰, 컨트롤러로 애플리케이션의 구성 요소를 나누어 개발 프로세스에서 각각의 구성 요소만 집주해서 개발하는 패턴
역할이 분리외어 있기에 재사용성과 확장성에 용이하다.
애플리케이션이 복잡해질 수록 모델과 뷰의 관계가 복잡해진다.애플리케이션의 데이터.
데이터베이스, 상수 변수 등을 뜻함.사용자 인터페이스 요소.
모델을 기반으로 사용자가 볼 수 있는 화면.
모델이 가지고 있는 정보를 떠로 저장하지 않으며, 화면에 표시하는 정보만을 가지고 있어야함.
변경이 일어나면 컨트롤러에 전달함.하나 이상의 모델과 하나 이상의 뷰를 연결하는 역할.
이벤트 등 메인 로직을 구성.
모델과 뷰의 생명주기 관리.]]></description><link>1.-cs/디자인패턴/mvc-패턴.html</link><guid isPermaLink="false">1. CS/디자인패턴/MVC 패턴.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[MVP 패턴]]></title><description><![CDATA[
MVC 패턴으로 파생된 패턴. 컨트롤러(Controller) 대신 프레젠터(Presenter)로 교체된 패턴.
뷰와 프레젠터는 일대일 관계.
때문에 MVC보다 강한 결합도를 지닌다.]]></description><link>1.-cs/디자인패턴/mvp-패턴.html</link><guid isPermaLink="false">1. CS/디자인패턴/MVP 패턴.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[자료구조]]></title><description><![CDATA[
데이터를 효율적으로 사용하기 위해 데이터를 정리하고 저장하는 방식
적에 맞게 데이터를 구성하여 검색, 삽입, 삭제 등의 작업을 가장 빠르게 처리할 수 있도록 설계하는 것 일렬로 나열되어 있는 자료 구조 Linked List
데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
<img alt="자료구조_연결리스트.png" src="99.-이미지/cs/자료구조_연결리스트.png" target="_self">prev 포인터와 next 포인터로 앞과 뒤의 노드를 연결.메모리가 허용하는 한 노드를 계속 추가할 수 있음.특정 위치의 데이터를 찾으려면 첫 번째 노드부터 차례로 따라가야함. 의 시간 소요중간 데이터 수정 필요시 앞뒤 노드의 포인터만 변경하면됨. 의 시간 소요Node, 실제 데이터와 다음 노드의 주소를 담는 공간Head, 리스트의 시작 노드next 포인터만 가짐.next 포인터와 prev포인터를 가짐.이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리킴.데이터의 삽입 삭제가 빈번하게 일어나고, 데이터의 전체 개수를 미리 예측하기 어려운 경우
Array
같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리에 위치에 있는 데이터의 집합
가장 기본적인 선형 자료구조로, 메모리 공간에 연속적으로 데이터를 배치함.선언 시 크기를 정할면 바꿀 수 없음.인덱스를 아는 경우, 의 시간 복잡도로 즉시 접근이 가능중간에 데이터를 넣거나 빼려면 뒤의 게이터들을 모두 밀거나 당겨야함. 의 비용이 듦.데이터 개수가 변하지 않고, 빠른 조회가 중요한 경우
Vector
동적으로 요소를 할당할 수 있는 동적 배열
배열의 단점인 고정크기를 해결한 가변 크기 배열저장 공간이 꽉 차면 자동으로 더 큰 메모리 공간을 할당함.배열처럼 인덱스를 통한 빠른 접근이 가능.맨 뒤 데이터를 추가하거나 삭제하는 것은 빠르지만, 중간 사입/삭제는 느림.데이터의 개수가 유동적으로 변할 때 가장 널리 쓰이는 표준 자료구조
Stack
마지막으로 들어간 데이터가 가장 첫 번째로 나오는 자료구조
데이터를 한쪽 끝에서만 넣고 뺄 수 있는 LIFO(Last In First Out, 후입선출) 구조가장 마지막에 들어온 데이터가 가장 먼저 나감.
push() : 데이터 삽입
pop() : 데이터 추출
peek() : 맨 위 데이터 확인
함수 호출 기록(call stack), Undo 등
Queue
먼저 들어간 데이터가 먼저 나오는 자료구조
한쪽에서는 넣고, 반대쪽에서는 빼는 FIFO(First In First Out, 선입선출) 구조가장 먼저 들어온 데이터가 가장 먼저 나감.
Enqueue(삽입) : 데이터 삽입
Dequeue(삭제) : 데이터 추출
프로세스 스케줄링, 인쇄 대기열, 너비 우선 탐색 등
일렬로 나열하지 않고 자료 순서나 관계가 복잡한 자료구조 정점(vertex)와 정점을 잇는 간선(Edge)으로 이루어진 비선형 자료구조.
정점과 간선으로 이루어진 집합
<br><img alt="자료구조_그래프.png" src="99.-이미지/cs/자료구조_그래프.png" target="_self">OutDegree : 정점에서 나가는 간선
InDegree: 정점으로 들어오는 간선간선에 방향이 있을 수도(유향), 없을 수도(무향) 있음.
간선과 정점 사이에 드는 비용인 가중치를 가질 수 있음.특정 노드에서 출발해 다시 자신에게 돌아오는 경로가 존재할 수 있음. 부모-자식 관계가 아닌, 데이터 간의 상호 연결 관계에 집중.SNS 관계, 지도/네비게이션(최단 경로), 웹 페이지 링크 구조 등
뿌리(Root)에서 가지가 뻗어 나가는 형태의 계층적 구조를 가지는 특수한 형태의 그래프
<br><img alt="자료구조_트리.png" src="99.-이미지/cs/자료구조_트리.png" target="_self">부모, 자식 계층 구조를 가짐.
하나의 부모 노드가 여러 자식 노드를 가질 수 있는 1:N 관계트리 내부에는 순환이 존재하지 않음.두 노드 사이의 경로는 오직 하나간선 수는 노드 수 - 1가장 위에 있는 노드.루트 노드와 리프 노드 사이에 있는 노드자식 노드가 없는 노드<br><img alt="자료구조_트리_요소.png" src="99.-이미지/cs/자료구조_트리_요소.png" target="_self">루트 노드부터 특정 노드까지 최간 거리로 갔을 때의 거리루트 노드부터 리프 노드까지 더리 중 가장 긴 거리루트 노드를 0레벨로 두고 깊이에 따라 증가트리내의 하위 집합, 트리 내에 있는 부분집합.자식의 노드 수가 두개 이하인 트리<br><img alt="자료구조_이진트리.png" src="99.-이미지/cs/자료구조_이진트리.png" target="_self">Full Binary Tree
자식 노드가 0 또는 두 개인 이진 트리Complete Binary Tree
왼쪽에서부터 채워져 있는 이진 트리.
마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 잇으며, 마지막 레벨의 경우 왼쪽부터 채워져 있음Degenerate Binary Tree
자식 노드가 하나밖에 없는 이진 트리Perfect Binary Tree
모든 노드가 꽉 차 있는 이진 트리Balanced Binary Tree
왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리BST, Binary Search Tree<br><img alt="자료구조_이진탐색트리.png" src="99.-이미지/cs/자료구조_이진탐색트리.png" target="_self">노드의 하위 트리의 오른쪽은 노드보다 큰 값, 왼쪽은 노드보다 작은 값을 가지는 트리
하위 트리 또한 같은 특성을 가짐.특정 값에 대해 큰 값, 작은 값이 정해져 있기에 검색에 용이
일반적으로 , 최악의 경우 소요Adelson-Velsky and Landis Tree
이진 탐색트리에서 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 트리
두 자식 서브트리의 높이는 항상 최대 1만큼 차이가 남.
높이 차이가 1보다 커지면 회전(rotation)을 통해 균형을 잡아 높이 차이를 줄임.탐색, 삽입, 삭제의 시간복잡도가 모두 <br><img alt="자료구조_AVL트리.png" src="99.-이미지/cs/자료구조_avl트리.png" target="_self">왼쪽 서브트리의 높이에서 오른 쪽 서브트리의 높이를 뺀 값 BF가 1이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한단계 높다는 것을 의미
BF가 0이면 왼쪽 서브트리와 오른쪽 서브트리의 높이가 같다는 것을 의미
BF가 -1이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한단계 낮다는 것을 의미
삽입 삭제 시 불균형 상태(BF가 -1, 0, 1이 아닌 경우) 가 되면 불균형 노드를 기준으로 서브트리의 위치를 변경하는 작업을 수행하여 트리의 균형을 맞추게 됨.삽입 삭제시 노드들의 배열에 따라 4가지(LL, RR, LR, RL)&nbsp;불균형이 발생할 수 있으며 각 상황마다 회전 방향을 달리하여 트리의 균형을 맞춤.Left Left Case, right rotation 수행
T1~4는 서브 트리<br><img alt="자료구조_AVL트리_LL.png" src="99.-이미지/cs/자료구조_avl트리_ll.png" target="_self">
y노드의 오른쪽 자식 노드를 z노드로 변경
z노드 왼쪽 자식 노드를 y노드 오른쪽 서브트리(T2)로 변경
y는 새로운 루트 노드가 됨
Right Right Case, left rotation 수행
T1~4는 서브 트리<br><img alt="자료구조_AVL트리_RR.png" src="99.-이미지/cs/자료구조_avl트리_rr.png" target="_self">
y노드의 왼쪽 자식 노드를 z노드로 변경
z노드 오른쪽 자식 노드를 y노드 왼쪽 서브트리(T2)로 변경
y는 새로운 루트 노드가 됨
Left Right Case, left, right 순으로 두번의 rotation 수행
T1~4는 서브 트리<br><img alt="자료구조_AVL트리_LR.png" src="99.-이미지/cs/자료구조_avl트리_lr.png" target="_self">Right Left Case, right, left 순으로 두번의 rotation 수행
T1~4는 서브 트리<br><img alt="자료구조_AVL트리_RL.png" src="99.-이미지/cs/자료구조_avl트리_rl.png" target="_self">Red Black Tree
AVL 트리와 같이 균형 이진 탐색 트리
각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장함.
해당 추가 비트는 트리가 균형을 유지하도록 하는 데 사용탐색, 삽입, 삭제의 시간복잡도가 모두 모든 노드는 빨간색 혹은 검은색임. 루트 노드는 검은색임.
모든 리프 노드(NIL)들은 검은색임.
(NIL : null leaf, 자료를 갖지 않고 트리의 끝을 나타내는 노드) 빨간색 노드의 자식은 검은색임.
즉, 빨간색 노드가 연속으로 나올 수 없음.
모든 리프 노드에서 Black Depth는 같음.
즉, 리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같음. Heap
최댓값 또는 최솟값을 빠르게 찾아내기 위해 고안된 완전 이진 트리 기반의 자료 구조
<br>일반적인 <a data-tooltip-position="top" aria-label="자료구조 > 이진 탐색 트리" data-href="자료구조#이진 탐색 트리" href="1.-cs/자료구조/자료구조.html#이진_탐색_트리_0" class="internal-link" target="_self" rel="noopener nofollow">이진 탐색 트리</a>와 달리 중복된 값을 허용함.
부모 노드와 자식 노드 간에만 상하 관계가 존재함.
좌우 노드 간의 크기 순서는 정해져 있지 않음.최대/최소 조회 : 데이터 삽입 : 데이터 삭제 : Max Heap
부모 노드의 키값이 자식 노드의 키 값보다 크거나 같은 힙.
루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야함.
각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함.부모 노드의 키값이 자식 노드의 키값보다 작거나 같은 힙.
루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 함.
각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함.<br><img alt="자료구조_힙.png" src="99.-이미지/cs/자료구조_힙.png" target="_self">Push
새로운 요소를 트리의 가장 마지막 자리에 추가
부모 노드와 비교하며 조건에 맞을 때까지 위로 올림.(Up-heap)
Pop, 기본적으로 루트 노드를 삭제함.
루트 노드(최댓값 혹은 최솟값)을 제거
마지막 노드를 루트 자리로 옮김
자식 노드와 비교하며 조건에 맞을 때까지 아래로 내림.(Down-heap) Priority Queue
우선순위 대기열
대기열에서 우선순위가 높은 요소가 우선적으로 먼저 제공되는 자료구조
<br>일반적인 <a data-tooltip-position="top" aria-label="자료구조 > 큐" data-href="자료구조#큐" href="1.-cs/자료구조/자료구조.html#큐_0" class="internal-link" target="_self" rel="noopener nofollow">큐</a>가 선입선출 방식임에 반해 데이터마다 부여된 우선순위에 따라 우선순위가 가장 높은 데이터가 먼저 나가는 자료구조<br><a data-tooltip-position="top" aria-label="자료구조 > 힙" data-href="자료구조#힙" href="1.-cs/자료구조/자료구조.html#힙_0" class="internal-link" target="_self" rel="noopener nofollow">힙</a>을 기반으로 구현됨
Enqueue(삽입) : 데이터를 큐에 넣을 때 그 데이터의 우선순위를 함께 설정
Dequeue(삭제) : 큐에 있는 데이터 중 가장 우선순위가 높은 데이터를 찾아 먼저 꺼냄. Map
특정 순서에 따라 키(Key)와 값(Value)의 쌍으로 매핑된 데이터를 저장하는 자료구조
맵 내에서 키는 중복될 수 없음.키를 알고 있다면 대응하는 값을 빠르게 찾을 수 있음.데이터 간의 관계를 저장하는 데 최적화되어 있음.
Set
중복을 허용하지 않고, 데이터의 순서를 보장하지 않는 자료구조
동일한 값을 두 번 이상 저장할 수 없음. 이미 있는 값을 넣으려하면 무시됨.데이터가 들어간 순서를 유지하지 않음.
단, 특정 구현체에 따라 정렬되거나 순서가 유지될 수 있음.특정 값이 셋 안에 존재하는지 여부를 확인하는 속도가 빠름.]]></description><link>1.-cs/자료구조/자료구조.html</link><guid isPermaLink="false">1. CS/자료구조/자료구조.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로세스와 스레드]]></title><description><![CDATA[프로세스(Process) 실행되고 있는 프로그램
CPU 스케줄링의 대상이 되는 작업(task)
프로그램이 메모리에 올라가 인스턴스화 된 것 스레드(Thread)
프로세스 내 작업의 흐름
프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 진행, 이후 OS의 CPU 스케줄러에 따라 프로세스를 실행<img alt="컴파일과정.png" src="99.-이미지/cs/컴파일과정.png" target="_self">소스 코드의 주석을 제거하고 헤더파일을 병합하여 매크로를 치환오류 처리, 코드 최적화 작업, 어셈블리어 변화어셈블리어를 목적 코드(object code), 기계어로 변환
해당 과정에서 확장자가 변경된 파일 생성됨.프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일 생성프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식
외부 의존도가 낮으나, 코드 중복 등 메모리 효율성이 떨어짐.프로그램 실행 시 필요할 때만 DLL(Dynamic Link Library)을 통해 참조하여 라이브러리를 사용하는 방식.
메모리 효율성에서 장점을 지니지만, 외부 의존도가 높아짐.<br><img alt="프로세스상태.png" src="99.-이미지/cs/프로세스상태.png" target="_self">Create
프로세스가 생성된 상태.<br>
fork() 또는 exec() 함수를 통해 생성. 이때 <a data-tooltip-position="top" aria-label="프로세스와 스레드 > PCB" data-href="프로세스와 스레드#PCB" href="1.-cs/운영체제/프로세스와-스레드.html#PCB_0" class="internal-link" target="_self" rel="noopener nofollow">PCB</a>가 할당됨.부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수.
주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등으 상속하지는 않음.새롭게 프로세스를 생성하는 함수Ready
CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태.
메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기Ready Suspended
메모리 부족으로 일시 중단된 상태.Running
CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태.Blocked
이떤 이벤트가 발생한 이후 대기하며 프로세스가 차단된 상태.Blocked Suspended
중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태.Terminated
메모리와 CPU 소유권을 모두 놓고 가능 상태.
비자발적 종료(abort), 할당 자원 한계치 오버, 부모 프로세스 종료, 사용자 kill 등<br><img alt="프로세스_메모리_구조.png" src="99.-이미지/cs/프로세스_메모리_구조.png" target="_self">Stack, 동적 할당
변수, 함수에 의해 가변하는 메모리 영역.
함수가 호출될 때마다 환경 등 특정 정보가 스택에 계속해서 저장됨.
재귀 함수 호출 시 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않음.Heap, 동적 할당
동적으로 할당되는 변수를 담는 메모리 영역.
malloc 또는 free 함수로 관리할 수 있으며, GC에 의해 관리되기도 함.BSS segment, Data segment, 정적 할당전역 변수 또는 static, const로 선언되어 있고 0으로 초기화, 초기화되어 있지 않음 변수들이 할당됨.전역 변수 또는 static, const로 선언되어 있고 0이 아닌 값으로 초기화 되어 있는 변수들이 할당됨.Code segment, 정적 할당
프로그램의 코드가 할당되는 메모리 영역Process Control Block
OS에서 프로세스에 대한 메타데이터를 저장한 데이터를 의미.
프로세스가 생성되면 OS가 해당 PCB를 생성프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 메모리가 할당됨.
해당 프로세스의 메타데이터들이 PCB에 저장되어 관리되며, 커널 스택의 맨 앞부분에서 관리됨.메타데이터(metadata)
데이터에 관한 구조화된 데이터이자 데이터를 설명하는 데이터.
정보를 효율적으로 이용하기 위해 일정한 규칙에 따라 콘텐츠에 부여되는 데이터
Ready, Blocked Suspended 등 프로세스의 상태 정보 저장프로세스 ID, 해당 프로세스의 자식 프로세스 ID컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보프로세스에서 실행해야할 다음 명령어의 주소에 대한 포인터프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보CPU 스케줄러에 의해 중단된 시간 등에 대한 정보프로세스 실행에 사용된 CPU 사용량, 실행 유저의 정보프로세스에 할당된 I/O 디바이스 목록
Context Switching
PCB를 기반으로 프로세스의 상태를 저장하고 로드시키는 과정
한 프로세스에 할당된 시간이 종료되거나 인터럽트에 의해 발생함.
한 시점에서 실행되고 있는 프로세스는 단 한 개이며(싱글 코어 기준), 동시에 많은 프로세스가 구동되는 것처럼 보이는 것은 컨텍스트 스위칭이 빠른 속도로 이루어지고 있기 때문<br><img alt="컨텍스트_스위칭.png" src="99.-이미지/cs/컨텍스트_스위칭.png" target="_self">컨텍스트 스위칭이 일어날 때 유휴 시간(idle time) 이 발생하며, 컨텍스트 스위칭 비용으로 캐시미스가 발생합니다.<br>컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪게 되며 이로 인해 <a data-tooltip-position="top" aria-label="메모리 > 캐시히트와 캐시미스" data-href="메모리#캐시히트와 캐시미스" href="1.-cs/운영체제/메모리.html#캐시히트와 캐시미스" class="internal-link" target="_self" rel="noopener nofollow">캐시미스</a>가 발생한다.스레드는 스택 영역을 제외한 모든 메모리를 공유
-&gt; 비용이 프로세스에 비해 적고 시간도 적게 걸림.멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것
하나 이상의 일을 병렬적으로 처리할 수 있으며 특정 프로세스의 메모리 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스를 이용해서 처리할 수 있으므로 신뢰성이 높은 강점이 있음.Inter Process Communication
프로세스끼리의 데이터를 주고받으며 공유 데이터를 관리하는 메커니즘Shared Memory
여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않음.
메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요File
보조기억장치에 저장되는 데이터 또는 서버에 저장되는 데이터를 기반으로 통신하는 방법Socket
네트워크 인터페이스(TCP, UDP 등)을 기반으로 통신하는 방법Pipe
부모 자식 프로세스 간의 통신을 위해 사용됨.
파이프 내 용량이 제한되어 있으며 읽기 속도 보다 쓰기 속도가 빨라질 수 없음.Unnamed Pipe
프로세스 간 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 통신하는 방법.
단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식.
양방향 통신을 원하는 경우 파이프를 두개 생성해야함.Named Pipe
파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 단방향, 양방향 파이프<br><img alt="명명파이프.png" src="99.-이미지/cs/명명파이프.png" target="_self">Message Queue
메시지를 큐 구조로 통신하는 것을 의미
커널에서 전역적으로 관리됨.
타 IPC 방식에 비해 직관적이고 간단함.<br>
<a data-tooltip-position="top" aria-label="프로세스와 스레드 > 공유메모리" data-href="프로세스와 스레드#공유메모리" href="1.-cs/운영체제/프로세스와-스레드.html#공유메모리_0" class="internal-link" target="_self" rel="noopener nofollow">공유메모리</a>를 통해 IPC를 구현하는 경우 동기화에 의해 기능구현이 복잡해지는데, 대안으로 사용Thread
프로세스의 실행 가능한 가장 작은 단위
프로세스는 여러 개의 스레드를 가질 수 있음.<br><img alt="스레드_공유자원.png" src="99.-이미지/cs/스레드_공유자원.png" target="_self">스레드는 코드, 데이터, 힙 영역을 서로 공유한다. 스택은 각각 생성된다.프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법
스레드끼리 자원을 공유하기 효율성이 높음
동시성에 큰 장점이 있으나, 문제 발생 시 다른 스레드에 영향을 줄 수 있어 프로세스에 영향을 줄 수 있음.<br>동시성
서로 독립적인 작업들을 작은 단위로 나누고 <a data-tooltip-position="top" aria-label="프로세스와 스레드 > 컨텍스트 스위칭" data-href="프로세스와 스레드#컨텍스트 스위칭" href="1.-cs/운영체제/프로세스와-스레드.html#컨텍스트_스위칭_0" class="internal-link" target="_self" rel="noopener nofollow">컨텍스트 스위칭</a>을 통해 빠르게 번갈아 가며 작업하여 동시에 실행되는 것처럼 보여지는 현상
Shared Resource
시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등을 의미
두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition) 이라 함.
접근 타이밍, 순서 등이 결괏값이 영향을 줄 수 있는 상태Critical Section
동시접근하려고 하는 자원에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역해당 임계 영역을 만족 시키기 위해서는 뮤텍스, 세마포어, 모니터를 사용해야한다.
세 방법 모두 상호 배제, 한정 대기, 융통성을 만족한다.Mutual Exclusion
한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음.
여러 개의 프로세스 또는 스레드가 동시에 공유 자원에 접근하는 것을 방지하며,
데이터의 일관성과 무결성을 보장함.Bounded Waiting
특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨.Progress
임계 구역에 들어간 프로세스가 없는 상태에서, 들어가려고 하는 프로세스가 여러 개 있다면 들어갈 수 있어야하며, 이 때 프로세스끼리 서로 방해하지 않는다.위 방법의 베이스가 되는 메커니즘이 락(Lock) 이다.락(Lock)
특정 자원을 한 번에 하나의 실행 단위(스레드/코루틴)만 사용할 수 있도록 잠그는 개념
Mutex(Mutual Exclusion)
프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금을 해제하는 객체.
잠금이 설정되면 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없다.
잠금 또는 잠금 헤제 두가지 상태만을 가지는 잠금 메커니즘.<br><img alt="뮤텍스.png" src="99.-이미지/cs/뮤텍스.png" target="_self">Lock 연산: Mutex를 획득하여 공유 자원에 대한 접근 권한을 얻음. 다른 프로세스 또는 스레드가 이미 Mutex를 보유하고 있다면, Lock 연산은 대기 상태로 들어가고 해당 Mutex를 보유하고 있는 프로세스 또는 스레드가 Mutex를 해제할 때까지 기다림.Unlock 연산: Mutex를 해제하여 다른 프로세스 또는 스레드가 공유 자원에 접근할 수 있도록 함.자원을 점유하고 있는 대상이 Lock을 할 수 있는 권한을 가지고 있어서 자원을 점유하기 시작할 때 들어가서 Lock을 걸어버림. 이렇게 되면 다른 대상들은 Unlock 상태가 될 때까지 기다렸다가 나중에 해당 공유 자원에 접근할 수 있음.Semaphore
일반화된 뮤텍스. 정수 값과 두 함수(wait, signal)로 공유 자원에 대한 접근을 처리함.wait() : 자신의 차례가 올 때까지 기다리는 함수. P 함수
signal() : 다름 프로세스로 순서를 넘겨주는 함수. V 함수<br><img alt="세마포어.png" src="99.-이미지/cs/세마포어.png" target="_self">프로세스 또는 스레드가 공유 자원에 접근하면 세마포어에서 wait(P 연산) 작업을 수행하고,
프로세스 또는 스레드가 공유 자원을 해제하면 세마포어에서 signal(V 연산) 작업을 수행함.P(Proberen) 연산: 세마포어 값(S)을 1 감소시킴. 만약 세마포어의 값이 0이라면, 해당 프로세스 또는 스레드는 대기 상태로 들어가게 됨. 이때 다른 프로세스나 스레드가 V 연산을 수행하여 세마포어 값을 1 증가시키면, 대기 중인 프로세스나 스레드 중 하나가 다시 실행되게 됨.V(Verhogen) 연산: 세마포어 값(S)을 1 증가시킴. 만약 세마포어의 값이 0 이상이라면, 대기 중인 다른 프로세스나 스레드 중 하나를 실행 상태로 전환킴.조건 변수가 없고 프로세스나 스레드가 세마포어 값을 수정할 때 다른 프로세스나 스레드는 동시에 세마포어 값을 수정할 수 없음.0 또는 1 값만 가질 수 있는 세마포어.
신호 기반으로 상호 배제가 일어나는 신호 메커니즘.
뮤텍스와 유사하게 동작함.여러 개의 값을 가질 수 있는 세마포어.
여러 자원에 대한 접근을 제어Monitor
둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만을 제공<br><img alt="모니터.png" src="99.-이미지/cs/모니터.png" target="_self">모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리.
상호 배제를 명시적으로 구현해줘야하는 뮤텍스/세마포어와 달리 상호 배제가 자동.
Dead-Lock
두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태.
아래 4가지 조건이 동시에, 모두 충족되어야만 교착 상태가 발생한다.Mutual Exclusion
한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능Hold and Wait
특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태No Preemption
다른 프로세스의 자원을 강제적으로 가져올 수 없음.Circular Wait
서로가 서로의 자원을 요구하는 상황다음과 같은 방법으로 교착 상태를 예방하고 해결할 수 있음.Prevention
데드락의 4가지 필요조건 중 하나를 강제로 제거하는 방식.
가장 강력하지만 자원 낭비가 심할 수 있음.프로세스가 실행되기 전에 필요한 모든 자원을 한꺼번에 요청하게 하거나, 자원이 없는 상태에서만 요청하게 함.자원에 고유 번호를 매기고, 반드시 낮은 번호에서 높은 번호 순서로만 자원을 요청하게 강제함.Avoidance
조건을 제거하지는 않지만, 자원을 할당하기 전에 데드락 발생 가능 여부를 미리 계산해서 안전할 때만 할당하는 방법. 은행원 알고리즘이 사용됨.은행원 알고리즘
총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘
Detection &amp; Recovery
데드락이 발생하도록 놔둔 뒤, 사후 처리를 하는 방식자원 할당 그래프(Resource Allocation Graph)를 주기적으로 검사하여 순환(Cycle) 이 생겼는지 찾아냄.데드락이 발견되면 다음 중 하나를 실행합니다.
프로세스 종료: 데드락에 연루된 프로세스를 하나씩 또는 모두 강제 종료함.
자원 선점: 데드락이 풀릴 때까지 특정 프로세스의 자원을 뺏어서 다른 프로세스에 줌.
Ignorance
데드락 발생 확률이 매우 낮을 때, 해결 비용보다 그냥 무시하고 시스템을 재부팅하는 게 경제적이라고 판단하는 방식]]></description><link>1.-cs/운영체제/프로세스와-스레드.html</link><guid isPermaLink="false">1. CS/운영체제/프로세스와 스레드.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[메모리]]></title><description><![CDATA[<img alt="메모리계층.png" src="99.-이미지/cs/메모리계층.png" target="_self">CPU 내부에 위치한 메모리, 휘발성, 속도가 가장 빠름. 기억 용량 적음.L1, L2 캐시 지칭. 휘발성, 속도 빠름, 기억 용량 적음.RAM. 휘발성, 속도 보통, 기억 용량 보통HDD, SSD, 비휘발성, 속도 낮음, 기억 용량 많음.Cache
데이터를 미리 복사해 놓는 임시 저장소.<br>
빠른 장치와 느린 장치에서 나오는 속도 차이레 따를 <a data-href="병목현상" href="1.-cs/네트워크/병목현상.html" class="internal-link" target="_self" rel="noopener nofollow">병목현상</a>을 줄이기 위한 메모리.속도 차이 해결을 위해 계층 간 위치한 계층을 캐싱 캐층이라 칭함.캐시를 직접 설정하는 경우 자주 사용하는 데이터를 기반으로 설정.
자주 사용하는 데이터에 대한 근거가 지역성. 지역성은 시간과 공간으로 나뉨.최근 사용한 데이터에 다시 접근하려는 특성최근 접근한 데이터를 이루고 있는 공간이나 해당 공간에 가까운 공간에 접근하려는 특성<br><img alt="캐시히트미스.png" src="99.-이미지/cs/캐시히트미스.png" target="_self">캐시 히트(Cache Hit) : 원하는 데이터를 캐시에서 찾음.
캐시 미스(Cache Miss) : 훤하는 데이터가 캐시에 존재하지 않아 메모리에서 찾아옴.
캐시 컨트롤러(Cache Controller) : 캐시 매핑과 캐시 미스 여부를 판단하는 CPU 내부의 하드웨어Cache Mapping
캐시가 히트되기 위해 매핑하는 방법Directed Mapping
메모리와 캐시를 일정 비율로 매핑하는 방법.
처리가 빠르지만 충돌 발생이 잦음.Associative Mapping
순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑.
충돌이 적지만 모든 블록을 탐색해야하기에 속도가 느림.Set Associative Mapping
직접 매핑과 연관 매핑을 합친 방식의 방법.
순서는 일치시키지만 집합을 두어 저장하여 블록화시켜 검색에 효율적.Expire Date이 있는 key-value 저장소.
same site 옵션을 strict로 설정하지 않았가면 다른 도메인에 요청했을 때 자동 전송.
최대 4KB까지 저장 가능하며 Expire Date 설정 가능.Expire Date가 없는 key-value 저장소.
최대 5MB까지 저장 가능하며 웹 브라우저를 종료해도 유지.
클라이언트에서만 수정 가능.Expire Date가 없는 key-value 저장소.
탭 단위로 생성하며, 탭을 종료하면 데이터가 삭제됨.
최대 5MB까지 저장 가능하며 클라이언트에서만 수정 가능.메인 DB 위에 Redis를 두어 캐싱 계층을 둘 수 있음.<br><img alt="Redis.png" src="99.-이미지/cs/redis.png" target="_self">Virtual Memory
메모리 관리 기법의 하나로, 실제 이용 가능한 메모리 자원을 추상화하여 대용량 메모리로 보이게 하는 기법<br><img alt="가상메모리.png" src="99.-이미지/cs/가상메모리.png" target="_self">가상 메모리는 가상 주소(logical address) 와 실제 주소(physical address) 가 매핑되어 있으며 메모리관리장치(memory management unit, MMU)에 의해 가상 주소가 실제 주소로 변환됨.프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리되며 속도 향상을 위해 TLB를 사용함.TLB
Translation Lookaside Buffer
메모리와 CPU 사이에 있는 가상 주소를 물리 주소로 변환하는 속도를 높이기 위한 고속 캐시
페이지 테이블에 있는 리스트를 보관, CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상
Swapping
메모리에서 당장 사용하지 않는 영역을 보조기억장치로 옮기고 보조기억장치의 일부분을 메모리처럼 불러와 사용하는 기법.Page Fault
프로세스의 주소 공간에는 존재하지만 현재 RAM에는 없는 데이터에 접근하는 경우 발생하는 예외
가상 주소에 접근하였으나 페이지가 존재하지 않는 경우 트랩 발생. OS에 알림.
OS는 보조기억장치로부터 사용하지 않는 프레임을 찾음.
해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 교체(스와핑)
페이지 테이블 갱신 및 재시작
Page, 가상 메모리를 사용하는 최소 크기 단위Frame, 실제 메모리를 사용하는 최소 크기 단위Thrashing
메모리의 페이지 폴트율이 높은 것을 의미하며 CPU 이용률이 낮아짐.
-&gt; 많은 프로세스가 동시에 메모리에 올라가게 되면 스와핑이 많이 일어나기 때문CPU 이용률이 낮아지게 되면 OS는 가용성을 올리기 위해 더 많은 프로세스를 메모리에 올리게 되고 이에 따라 악순환이 반복Working Set
프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것. -&gt; 탐색에 드는 비용과 스와핑을 줄임.Page Fault Frequency
페이지 폴트 빈도를 조절하는 방법.
상한선과 하한선을 배치해 상한에 도달하면 프레임을 늘리고 하한에 도달하면 프레임을 줄임.메모리는 프로그램을 할당할 때 시작 메모리 위치
메모리의 할당 크기
를 기반으로 할당하게 됨.
메모리에 프로세스를 연속적으로 공간을 할당하는 방법.Fixed Partition Allocation
메모리를 미리 나누어 관리하는 방식. 메모리가 미리 나뉘어 있기 때문에 내부 단편화가 발생Variable Partition Allocation
매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식. 외부 단편화 발생 가능.
최초적합(first fit) : 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
최적적합(best fit) : 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
최악적합(worst fit) : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
Internal Fragmentation
메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상External Fragmentation
메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상할당할 수 있는 비어있는 메모리 공간메모리에 프로세스를 연속적이지 않게 할당하는 방법
메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 메모리를 프로그램에 할당하는 방법.Paging
동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
홀의 크기가 균일하지 않은 문제가 여전히 존재
주소 변환 복잡Segmentation
페이지 단위가 아닌 의미 단위인 세그먼트(segment)로 나누는 방식.
함수 단위 또는 프로세스를 이루는 메모리의 영역 별(코드, 데이터, 스택, 힙) 단위로 나누어 할당
공유 및 보안 측면에서 장점
홀의 크기가 균일하지 않은 문제가 여전히 존재Paged Segmentation
프로그램을 세그먼트로 나눠 공유나 보안 측면에 강점을 두고 동일한 크기의 페이지 단위로 할당스와핑은 페이지 교체 알고리즘을 기반으로 일어남.Offline Algorithm
개념적인 알고리즘이며 다른 알고리즘과의 성능 비교 지표에 대한 상한 기준 제공.
미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘First In First Out
가장 먼저 들어온 페이지를 교체 영역에 가장 먼저 놓는 방법Least Recently Used
참조가 가장 오래된 페이지를 교체하는 방법.
참조 기간을 알아햐하기 때문에 각 페이지마다 계수기, 스택을 두어야함.<br><img alt="페이지알고리즘.png" src="99.-이미지/cs/페이지알고리즘.png" target="_self" style="width: 350px; max-width: 100%;">기존에 할당되어 있으면 할당된 위치와 스왑, 할당된 페이지가 없다면 가장 오랜된 페이지 제거 및 시프트 후 추가. 해시 테이블 및 이중 연결 리스트로 구현 가능Not Used Recently
Clock 알고리즘이라고도 하며, 플래그 비트를 두어 시계 방향으로 돌며 참조되지 않은 페이지를 찾아 프로세스를 교체하고 플래그를 바꾸는 방법.Least Frequently Used
가장 참조 횟수가 적은 페이지를 교체하는 방법.]]></description><link>1.-cs/운영체제/메모리.html</link><guid isPermaLink="false">1. CS/운영체제/메모리.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[운영체제와 컴퓨터]]></title><description><![CDATA[
OS, Operating System
사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
한정된 메모리, 시스템 자원을 효율적으로 분배하는 주체
펌웨어(firmware)와는 다르다
Firmware와 OS는 유사하나, 소프트웨어 추가 설치 유무에 따라 다르다. CPU 스케줄링 및 프로세스 관리
: CPU 소유권 할당, 프로세스의 생성과 삭제, 자원 할당 및 반환 관리
메모리 관리
: 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리
디스크 파일 관리
: 디스크 파일을 어떤 방법으로 보관할지 관리
I/O 디바이스 관리
: I/O 디바이스 간의 데이토 통신을 관리
<img alt="OS구조.png" src="99.-이미지/cs/os구조.png" target="_self">System Call
운영체제가 커널에 접근하기 위한 인터페이스
유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출 시 사용<br><img alt="시스템콜1.png" src="99.-이미지/cs/시스템콜1.png" target="_self">
컴퓨터 자원에 대한 직접 접근을 차단, 프로그램을 다른 프로그램으로부터 보호.<br><img alt="시스템콜2.png" src="99.-이미지/cs/시스템콜2.png" target="_self">
프로세스나 스레드에서 운영체제로의 요청 또한 시스템 콜을 거침.시스템콜은 하나의 추상화 계층. 때문에 네트워크 통신이나 데이터베이스 같은 Low level 처리에 대한 부분을 신경 쓰지 않고 프로그램을 구현할 수 있음.시스템 콜이 작동할 때 modebit에 따라 유저 모드와 커널 모드를 구분하는 값. 즉, 플래그 변수<br><img alt="modebit.png" src="99.-이미지/cs/modebit.png" target="_self">유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침법하지 못하는 모드모든 컴퓨터 자원에 접근할 수 있는 모드운영체제의 핵심. 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추Central Processing Unit
산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 장치.
인터럽트에 의해 메모리에 존재하는 명령어를 해석해서 실행하는 장치.커널이 프로그램을 메모리에 올려 프로세스로 생성. CPU가 이를 처리ALU, Arithmetic Logic Unit
산술 연산과 논리 연산을 계산하는 디지털 회로CU, Control Unit
프로세스 조작을 지시하는 장치.
입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정Registor
CPU 내부에 위치하는 매우 빠른 임시기억장치.
CPU와 직접적으로 연결되어 있으므로 연산속도가 메모리보다 빠름.
CPU는 자체적으로 데이터를 저장할 수 없기에 레지스터를 거쳐 데이터를 전달.Interrupt
외부 신호가 들어오면 CPU를 잠시 정지시키는 것
인터럽트가 발생되면 핸들러 함수가 모여 있는 벡터로 이동하여 핸들러가 함수가 실행됨.
인터럽트 간에는 우선순위가 존재하며, 우선순위에 따라 실행됨.I/O 디바이스에서 발생하는 인터럽트
인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스 내부의 로컬버퍼에 접근하여 작업을 수행트랩(trap)이라고도 함.
프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동Direct Memory Access Controller
I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
CPU의 부하를 덜어주지만, 하나의 작업을 동시에 실행하는 것은 불가<br><a data-tooltip-position="top" aria-label="메모리" data-href="메모리" href="1.-cs/운영체제/메모리.html" class="internal-link" target="_self" rel="noopener nofollow">Memory</a>
전자회로에서 데이터, 상태, 명령어 등을 기록하는 장치.
보통 메모리라함은 RAM(Random Access Memory)를 의미함.Timer
특정 프로그램에 시간 제한을 다는 역할을 수행하는 장치
시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재.Device Controller
I/O 디바이스 내부에 위치하는 CPU.
동 위치에 있는 로컬 버퍼는 각 디바이스에서 데이터를 임시로 저장하기 위한 메모리]]></description><link>1.-cs/운영체제/운영체제와-컴퓨터.html</link><guid isPermaLink="false">1. CS/운영체제/운영체제와 컴퓨터.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CPU 스케줄링 알고리즘]]></title><description><![CDATA[CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 스레드 단위로 CPU에 할당함.
CPU 스케줄링 알고리즘 비선점형 FCFS
SJF
우선순위 선점형 라운드 로빈
SRF
다단계 큐 Non-Preemptive
프로세스가 스스로 CPU 소유권을 포기하는 방식.
강제로 프로세스를 중지하지 않기 때문에 <a data-tooltip-position="top" aria-label="프로세스와 스레드 > 컨텍스트 스위칭" data-href="프로세스와 스레드#컨텍스트 스위칭" href="1.-cs/운영체제/프로세스와-스레드.html#컨텍스트 스위칭" class="internal-link" target="_self" rel="noopener nofollow">컨텍스트 스위칭</a>으로 인한 부하가 적음.First Come, First Served
가장 먼저 온 것을 가장 먼저 처리하는 알고리즘.
길게 수행되는 프로세스로 인해 Convoy Effect가 발생하는 단점이 존재.특정 프로세스가 준비 큐(Ready Queue)에서 오래 기다리는 현상Shorest Job First
실행 시간이 짧은 프로세스를 가장 먼저 실행하는 알고리즘.
Starvation이 발생하는 단점이 있으며, 평균 대기 시간이 가장 짧음.
실제 실행 시간을 알 수 없음.긴 수행 시간을 가진 프로세스가 실행되지 않는 현상SJF 스케줄링에서 오래된 작업일수록 우선순위를 높이는 방법을 사용해 보완한 알고리즘.
FCFS를 활용해 만들기도 하며 선점형, 비선점형적인 우선순위 스케일링 알고리즘을 칭하기도 함.Preemptive
현재 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식.
현대 운영체제가 사용하는 방식.각 프로세스에 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘.<br>q의 할당 시간이 부여되고, N개의 프로세스가 운영되는 경우 (N-1) * q 시간이 지나면 순서가 오게됨. 할당 시간이 너무 크면 <a data-tooltip-position="top" aria-label="CPU 스케줄링 알고리즘 > FCFS" data-href="CPU 스케줄링 알고리즘#FCFS" href="1.-cs/운영체제/cpu-스케줄링-알고리즘.html#FCFS_0" class="internal-link" target="_self" rel="noopener nofollow">FCFS</a>가 되고 짧으면 <a data-tooltip-position="top" aria-label="프로세스와 스레드 > 컨텍스트 스위칭" data-href="프로세스와 스레드#컨텍스트 스위칭" href="1.-cs/운영체제/프로세스와-스레드.html#컨텍스트 스위칭" class="internal-link" target="_self" rel="noopener nofollow">컨텍스트 스위칭</a>이 잦아져 오버헤드가 발생함.전체 작업 시간은 길어지지만 평균 응답 시간은 짧아짐.
로드밸런서에서 트래픽 분산 알고리즘으로 사용됨.Shortest Remaining Time First
작업 중 더 짧은 수행 시간을 가진 프로세스가 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘.우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 다른 스케줄링 알고리즘을 적용한 것
큐 간의 프로세스 이동이 불가능하므로 스케줄링 부담이 적지만 유연성이 떨어짐.<br><img alt="다단계_큐.png" src="99.-이미지/cs/다단계_큐.png" target="_self">]]></description><link>1.-cs/운영체제/cpu-스케줄링-알고리즘.html</link><guid isPermaLink="false">1. CS/운영체제/CPU 스케줄링 알고리즘.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[처리량과 지연 시간]]></title><description><![CDATA[Throughput
링크 내에서 성공적으로 전달된 데이터의 양.일반적으로 얼만큼의 트래픽을 처리했는지 나타냄.
많은 트래픽 처리 == 많은 처리량단위: bps(bit per second)트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러, 하드웨어 스펙에 영향을 받음.<img alt="처리량.png" src="99.-이미지/cs/처리량.png" target="_self" style="width: 300px; max-width: 100%;">
트래픽이 많아졌다. == 흐르는 데이터가 많아졌다.
처리량이 많아졌다. == 트래픽이 많아졌다.
Traffic
특정 시점에 링크 내에 흐르는 데이터의 양Bandwidth
주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수Latency
요청이 처리되는 시간.
데이터가 두 장치 사이를 왕복하는 데 걸린 시간링크 타입(무선, 유선), 패킷 크기, 라우터의 패킷 처리 시간에 영향을 받음.Packet
네트워크를 통해 데이터를 주고 을 때, 원래의 큰 데이터를 일정한 크기로 잘게 나눈 데이터 조각
헤더(Header)와 데이터(Payload)로 구성]]></description><link>1.-cs/네트워크/처리량과-지연-시간.html</link><guid isPermaLink="false">1. CS/네트워크/처리량과 지연 시간.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OSI 7계층]]></title><description><![CDATA[<img alt="네트워크_계층.png" src="99.-이미지/cs/네트워크_계층.png" target="_self">사용자가 네트워크 서비스에 직접 접근할 수 있도록 인터페이스를 제공하는 최상위 계층입니다.
기능: 사용자 인터페이스 제공, 전자우편, 데이터베이스 관리 등
프로토콜: HTTP, FTP, SMTP, DNS, SSH, Telnet 데이터 단위(PDU): Data / Message
정보: 사용자 데이터 그 자체를 포함하며, 특정 서비스(웹, 메일 등)를 구분하는 식별 정보가 포함됩니다.
응용 계층으로부터 받은 데이터를 표준 시스템 형식으로 변환하거나, 하위 계층의 데이터를 응용 계층에 맞게 변환합니다.
기능: 데이터 인코딩/디코딩, 암호화/복호화, 데이터 압축
프로토콜: JPEG, MPEG, ASCII, SSL, TLS 데이터 단위(PDU): Data
정보: 데이터의 구문(Syntax)과 의미를 정의하는 제어 정보가 포함됩니다.
응용 프로그램 간의 통신(세션)을 설정, 유지, 종료하고 동기화하는 역할을 수행합니다.
기능: 세션 관리(Full-duplex, Half-duplex), 동기점 제공을 통한 복구
프로토콜: NetBIOS, RPC, WinSock 데이터 단위(PDU): Data
정보: 데이터 스트림 내에 동기점을 삽입하여 전송 중단 시 복구할 수 있는 제어 정보를 포함합니다.
송신 프로세스와 수신 프로세스 간의 신뢰성 있고 투명한 데이터 전송을 보장하는 계층입니다.
기능: 오류 제어, 흐름 제어, 혼잡 제어, 데이터 분할 및 재조립
프로토콜: TCP, UDP 데이터 단위(PDU): Segment(TCP) / Datagram(UDP)
헤더 정보: 포트 번호(Port Number), 순서 번호(Sequence Number), 오류 검출 코드 등
여러 네트워크 노드를 거쳐 데이터를 목적지까지 가장 안전하고 빠른 경로로 전달하는 경로 선택(Routing) 계층입니다.
기능: 라우팅(Routing), 논리적 주소 지정(Addressing)
프로토콜: IP, ICMP, ARP, RIP, BGP 데이터 단위(PDU): Packet
헤더 정보: 출발지 및 목적지 IP 주소, 프로토콜 타입, TTL(Time To Live) 등
물리 계층을 통해 송수신되는 데이터의 물리적 전송 오류를 감지하고 수정하여 신뢰성을 확보합니다.
기능: 프레임 동기화, 흐름 제어, 물리적 주소 지정
프로토콜: Ethernet, HDLC, PPP 데이터 단위(PDU): Frame
헤더/트레일러 정보: MAC 주소, 프리앰블, FCS(Frame Check Sequence - 오류 검출) 등
데이터를 전기적, 기계적, 기능적 특성을 가진 신호로 변환하여 물리적 매체 위로 전송합니다.
기능: 비트(Bit) 단위의 신호 송수신, 전기적 규격 정의
장비: 케이블(UTP, 광섬유), 허브, 리피터 데이터 단위(PDU): Bit
정보: 별도의 헤더가 존재하지 않으며, 오직 '0'과 '1'의 전기적 신호 흐름만 존재합니다.
]]></description><link>1.-cs/네트워크/osi-7계층.html</link><guid isPermaLink="false">1. CS/네트워크/OSI 7계층.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크 기기]]></title><description><![CDATA[여러 장비를 연결하고 데이터 통신을 중재, 목적지가 연결된 포트로만 전기 신호를 보내 데이터를 전송하는 통신 네트워크 장비.
로드 밸런서라고도 칭함.
서버의 부하를 분산하는 기기
클라이언트로부터 오는 요청들을 뒤쪽의 여러 서버로 나누는 역할
트래픽 증가를 목표로 함.Router
여러 개의 네트워크를 연결, 분할, 구분시켜주는 역할.
다른 네트워크에 존재하는 장치끼리 데이터를 주고 받을 때 패킷 소모를 최소화하고 경로를 최적화하여 최소 경로로 패킷을 포워딩하는 장비L2 스위치의 기능과 라우팅 기능을 갖춘 장비
L3 == 라우터
라우팅은 SW 기반과 HW 기반으로 나뉘는데, HW 기반 라우팅을 수행하는 것이 L3 스위치MAC 주소를 MAC 주소 테이블을 통해 관리, 연결된 장치로부터 패킷이 왔을 때 패킷 전송을 담당.
IP를 이해하지 못하며 단순히 패킷의 MAC주소를 읽어 스위칭함.
테이블에 목적지가 존재하지 않다면 전체 포트에 전달
일정 시간 이후 테이블 내 MAC 주소 삭제 기능 포함.Bridge
두 개의 근거리 통신망을 상호 접속할 수 있도록 하는 통신망 연결 장치
포트와 포트 사이의 다리 역할
통신망 범위 확장 및 통합에 사용Network Interface Card
LAN 카드, 컴퓨터 내에 설치하는 확장 카드
2대 이상의 컴퓨터 네트워크를 구성하는데 사용
카드 별로 MAC 주소 보유Repeater
증폭 장치, 신호 정도를 증폭하여 다른 쪽으로 전달Access Point]]></description><link>1.-cs/네트워크/네트워크-기기.html</link><guid isPermaLink="false">1. CS/네트워크/네트워크 기기.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[네트워크 분류]]></title><description><![CDATA[Local Area Network근거리 통신망.
건물 단위와 같이 좁은 공간에서 운영.
전송 속도가 빠르고 혼잡하지 않음.MetroPolitan Area Network대도시 지역 통신망
도시 단위와 같이 넓은 지역에서 운영.
평균 속도의 전송 속도. <a data-tooltip-position="top" aria-label="네트워크 분류 > LAN" data-href="네트워크 분류#LAN" href="1.-cs/네트워크/네트워크-분류.html#LAN_0" class="internal-link" target="_self" rel="noopener nofollow">|LAN</a>에 비해 혼잡.Wide Area Network광역 네트워크
국가 또는 대륙 단위의 넓은 지역에서 운영.<br>
낮은 속도의 전송 속도. <a data-tooltip-position="top" aria-label="네트워크 분류 > MAN" data-href="네트워크 분류#MAN" href="1.-cs/네트워크/네트워크-분류.html#MAN_0" class="internal-link" target="_self" rel="noopener nofollow">MAN</a>에 비해 혼잡.]]></description><link>1.-cs/네트워크/네트워크-분류.html</link><guid isPermaLink="false">1. CS/네트워크/네트워크 분류.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[네트워크 성능 분석 명령어]]></title><description><![CDATA[Packet INternet Groper
네트워크 상태를 확인하려는 대상 노드를 향해 일정 크기의 패킷을 전송.ping [IP 또는 도메인 주소]
노드의 패킷 수신 상태, 도달 시간 확인 가능.
네트워크 연결 상태 확인.TCP/IP 프로토콜 중 ICMP 프로토콜 사용.
ICMP 프로토콜을 지원하지 않는 기기를 대상으로 실행 불가능.
네트워크 정책상 ICMP 및 traceroute를 차단 하는 경우 실행 불가.접속되어 있는 서비스들의 네트워크 상태를 표시.netstat
네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등 표시.
주로 서비스 포트 개방 여부를 확인할 때 사용.DNS에 관련된 내용을 확인.nslookup
특정 도메인에 매핑된 IP를 확인하기 위해 사용.목적지 노드까지 네트워크 경로를 확인할 때 사용.traceroute [IP 또는 도메인 주소]
목적지 노드까지 구산들 중 어느 구간에서 응답 시간이 느려지는지 확인 가능.
윈도우에서는 tracert를 사용.]]></description><link>1.-cs/네트워크/네트워크-성능-분석-명령어.html</link><guid isPermaLink="false">1. CS/네트워크/네트워크 성능 분석 명령어.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[네트워크 토폴로지]]></title><description><![CDATA[
Network Topology
노드와 링크가 어떻게 배치되어 있는지에 대한 방식, 연결 형태
Tree Topology
계층형 토폴로지라 칭하기도함. 트리 형태로 배치한 네트워크 구성노드의 추가, 삭제가 쉬움.
특정 노드에 트래픽이 집중될 때 하위 노드에 영향을 끼칠 수 있음.Bus Topology
중앙 통신 회선 하나에 여러개의 노드가 연결되어 공유하는 네트워크 구성
<a data-tooltip-position="top" aria-label="네트워크 분류 > LAN" data-href="네트워크 분류#LAN" href="1.-cs/네트워크/네트워크-분류.html#LAN" class="internal-link" target="_self" rel="noopener nofollow">근거리 통신망</a>에서 사용설치 비용이 적고 신뢰성이 우수
노드의 추가, 삭제가 쉬움.
스푸핑의 위험성이 있음.Spoofing
LAN 상에서 송신부의 패킷을 송신과 관련 없는 다른 호스트에 가지 않도록하는 스위칭 기능을 마비시키거나 속여서 특정 노드에 피킷이 오도록 처리하는 것<br><img alt="스푸핑.png" src="99.-이미지/cs/스푸핑.png" target="_self" style="width: 400px; max-width: 100%;">Star Topology
중앙에 있는 노드에 모두 연결된 네트워크 구성노드의 추가, 삭제가 쉬움.
에러 탐지가 쉽고 패킷 충돌 발생가능성이 낮음.중앙 노드에 장애가 발생하는 경우 네트워크 전체가 마비
설치 비용 고가Ring Topology
각 노드가 양 옆의 노드와 연결하여 전체적으로 고리처럼 구성하는 네트워크노드가 증가되어도 네트워크 상의 손실이 거의 없음.
충돌 발생 가능성이 적으며 노드의 고장 발견이 쉬움.네트워크 구성 변경이 어려움.
회선 장애 발생 시 네트워크 전체에 영향.Mesh Topology
그물망 처럼 연결되어 있는 네트워크 구성하나의 단말 장치에 장애가 발생해도 여러 개의 경로가 존재하므로 지속적으로 사용할 수 있음.
트래픽 분산 처리 가능.
노드 추가가 어렵고 구축, 운용 비용이 고가.]]></description><link>1.-cs/네트워크/네트워크-토폴로지.html</link><guid isPermaLink="false">1. CS/네트워크/네트워크 토폴로지.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[병목현상]]></title><description><![CDATA[
Bottleneck
전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한 받는 현상
<a data-tooltip-position="top" aria-label="네트워크 토폴로지" data-href="네트워크 토폴로지" href="1.-cs/네트워크/네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">토폴로지</a>가 병목 현상을 찾을 때 중요한 기준이됨.병목 현상의 주된 원인
네트워크 대역폭
네트워크 토폴로지
서버 CPU, 메모리 사용량
비효율적인 네트워크 구성
]]></description><link>1.-cs/네트워크/병목현상.html</link><guid isPermaLink="false">1. CS/네트워크/병목현상.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[홉바이홉 통신]]></title><description><![CDATA[
Hop By Hop
각 패킷이 여러 개의 라우터를 건너가는 모습을 비유적으로 표현
IP 주소를 통해 통신하는 과정을 말함.홉(hop)이란 사전적 의미로는 '한 발로 깡충깡충 뛰다', '휙휙 바꾸다' 등의 뜻을 가지는데, 이는 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습을 비유적으로 표현한 것수많은 서브 네트워크 속에서 라우터에 있는 라우팅 테이블의 IP를 기반으로 패킷을 전달하고 또 전달해나가며 라우팅을 수행하며 최종 목적지까지 패킷을 전달함.즉,&nbsp;통신 장치에 있는 라우팅 테이블의 IP를 통해 시작 주소부터 시작하여 다음 IP로&nbsp;계속해서 이동하는 라우팅 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신이동 과정에서 캡슐화와 비캡슐화가 반복적으로 일어남.Routing Table
송신지에서 수신지까지 도달하기 위해 사용
라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어 있는 리스트게이트웨이와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가짐Gateway
서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어서로 다른 네트워크 상의 통신 프로토콜을 변환해주는 역할을 하기도 함.
라우팅 테이블을 통해 확인 가능.]]></description><link>1.-cs/네트워크/홉바이홉-통신.html</link><guid isPermaLink="false">1. CS/네트워크/홉바이홉 통신.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[IP 주소 체계]]></title><description><![CDATA[IPv4와 IPv6로 나뉨.IPv4 : 32비트, 8비트 단위로 나누어 표기(ex. 123.45.67.89)
IPv6 : 64비트, 16비트 단위로 나누어 표기(ex. 2001:db8:ff00:42:8329)Classful network addressing
A,B,C,D,E 클래스로 구분하여 할당하는 방식.<img alt="클래스기반_IP할당.png" src="99.-이미지/cs/클래스기반_ip할당.png" target="_self" style="width: 450px; max-width: 100%;">10진수로 표현되는 IP를 2진수로 치환하였을 때A Class : 0으로 시작
B Class : 10으로 시작
C Class : 110으로 시작
D Class : 1110으로 시작
E Class : 1111으로 시작으로 클래스를 구분할 수 있다.각 클래스의 첫번째 주소는 네트워크 주소, 마지막 주소는 브로드캐스트용 주소Dynamic Host Configuration Protocol
IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜네트워크 장치의 IP주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때 마다 자동으로 IP 주소 할당 가능Network Address Translation
패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법사설IP &lt;-&gt; 공인IP내부 네트워크에서 사용한 IP주소와 외부에 드러나는 IP주소를 다르게 유지 가능]]></description><link>1.-cs/네트워크/ip-주소-체계.html</link><guid isPermaLink="false">1. CS/네트워크/IP 주소 체계.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[객체지향 프로그래밍]]></title><description><![CDATA[OOP, Object-Oriented Programming
객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급해 객체 내부에 선언된 메서드를 활용하는 방식의 프로그래밍
설계에 많은 시간이 소요됨.
처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림.abstraction
복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것Encapsulation
객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉Inheritance
상위 클래스의 특성을 하위 클래스가 이어받아서 재사용 또는 추가, 확장할 수 있는 특징.
코드의 재사용, 계층적 관계 생성, 유지 보수성 측면에서 중요.Polymorphism
하나의 메서드나 클래스가 다양한 방법으로 동작하는 특징.
ex) overloading, overridingOverloading
같은 이름을 가진 메서드를 여러 개 두는 기능.
함수의 타입, 매개변수의 유형, 개수 등으로 구별
컴파일 중 발생하는 '정적' 다형성class Person { fun eat(a: String){...} fun eat(a: String, b: String){...} // 두 함수는 함수명은 같으나 다른 함수.
}
Overriding
상위 클래스로부터 상속받은 메서드를 하위 클래스에서 재정의하는 기능.
런타임 중에 발생하는 '동적' 다형성class Animal { fun bark(){ print("mumu") } } class Dog : Animal { @Override fun bark(){ print("walwal") }
}
...
SOLID 원칙을 준수하여 설계 S : 단일 책임 원칙
O : 개방-폐쇄 원칙
L : 리스코프 치환 원칙
I : 인터페이스 분리 원칙
D : 의존 역전 원칙
SRP, Single Responsubility Principle
모든 클래스는 각각 하나의 책임단 가져야하는 원칙.
A 로직이 존재할 때, 클래스 a가 로직 A에 관한 클래스여야함.
클래스 a 수정 시, 로직 A와 관련된 수정이어야 함.OCP, Open Closed Principle
유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록하며, 수정 시 닫혀 있어야하는 원칙.
기존 코드는 잘 변경하지 않으면서도 확장은 쉽게 가능해야함.LSP, Liskov Substitution Principle
객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙.
-&gt; 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가야함.ISP, Interface Segregation Principle
하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙.DIP, Dependency Inversion Principle
자신보다 변하기 위운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변화에 영향을 받지 않게 하는 원칙.
상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립.]]></description><link>1.-cs/프로그래밍-패러다임/객체지향-프로그래밍.html</link><guid isPermaLink="false">1. CS/프로그래밍 패러다임/객체지향 프로그래밍.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[절차지향 프로그래밍]]></title><description><![CDATA[
코드 자체가 수행되어야할 순서대로 구성되는 프로그래밍 기법
로직이 수행되어야 할 연속적인 꼐산 과정으로 이루어짐.
코드 가독성 실행 속도 모듈화 한계
유지 보수성
]]></description><link>1.-cs/프로그래밍-패러다임/절차지향-프로그래밍.html</link><guid isPermaLink="false">1. CS/프로그래밍 패러다임/절차지향 프로그래밍.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[ARP]]></title><description><![CDATA[
Address Resolution Protocol
IP 주소로부터 MAC 주소를 구하는 IP와 MAC 주소의 다리 역할을 하는 프로토콜
ARP를 통해 논리적 주소인 IP를 물리적 주소인 MAC 주소로 변환함.
반대로 RARP를 통해 실제 주소인 MAC 주소를 가상 주소인 IP로 변환하기도 함.클라이언트가 ARP Request 브로드캐스트를 보내서 IP주소에 해당하는 MAC 주소를 찾으며,
해당 MAC 주소에 맞는 서버가 ARP Reply 유니캐스트를 통해 MAC 주소를 반환하는 과정을 거쳐 IP 주소에 맞는 MAC 주소를 찾게 됨.BroadCast
송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식UniCast
고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식]]></description><link>1.-cs/네트워크/arp.html</link><guid isPermaLink="false">1. CS/네트워크/ARP.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[TCP／IP 4계층]]></title><description><![CDATA[<img alt="네트워크_계층.png" src="99.-이미지/cs/네트워크_계층.png" target="_self">특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 설계됨.Application Layer
응용 계층이라고도함.
FTP, HTTP, SSH, SMTP, DNS 등 응용프로그램이 사용되는 프로토콜 계층.
실질적으로 사람들에게 제공하는 계층File Transfer Protocol
장치와 장치 간의 파일을 전송하는 데 사용되는 표준 프로토콜Secure SHell
보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 프로토콜HyperText Transfer Protocol
World Wide Web을 위한 데이터 통신의 기초
웹 사이트를 사용하는 데 사용하느 프로토콜Simple Mail Transfer Protocol
전자 메일 전송을 위한 인터넷 표준 통신 프로토콜Domin Name System
도메인 이름과 IP주소를 매핑해주는 서버Transport Layer
애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때 중계 역할을 하는 계층송신자와 수신자를 연결하는 통신 서비스를 제공
연결 지향 데이터 스트림, 신뢰성, 흐름 제어 제공패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해서 연결
신뢰성을 구축하여 수신 여부를 확인.<br>
<a data-tooltip-position="top" aria-label="TCP／IP 4계층 > 전송 계층 > 가상회선 패킷 교환 방식" data-href="TCP／IP 4계층#전송 계층#가상회선 패킷 교환 방식" href="1.-cs/네트워크/tcp／ip-4계층.html#전송_계층_0" class="internal-link" target="_self" rel="noopener nofollow">가상회선 패킷 교환 방식</a>데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 함(연결 지향형)
각 패킷에는 가상회선 식별 번호(Virtual Circuit Identifier, VCI)가 포함됨.
모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착함.
데이터그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행TCP는 신뢰성을 확보할 때 3-way handshake 작업을 진행함.<br><img alt="3way_handshake.png" src="99.-이미지/cs/3way_handshake.png" target="_self" style="width: 450px; max-width: 100%;">
클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보냄.
서버는 클라이언트의 SYN을 수신, 서버의 ISN와 클라이언트 ISN + 1인 승인번호를 보냄.
클라이언트는 서버의 ISN + 1인 승인번호를 ACK에 담아 서버에 보냄.
Syncronization, 연결 요청 플래그Acknowledgement, 응답 플래그Initial Sequence Numbers, 초기 네트워크 연결 시 할당되는 32비트 고유 시퀀스 번호TCP가 연결을 헤제할 때는 4-way handshake 과정이 발생<br><img alt="4way_handshake.png" src="99.-이미지/cs/4way_handshake.png" target="_self" style="width: 450px; max-width: 100%;">
클라이언트가 FIN으로 설정된 세그먼트를 송신. 클라이언트 FIN_WAIT_1 상태 돌입 및 서버 응답 대기
서버가 ACK 승인 세그먼트 송신. 서버 CLOSE_WAIT 상태 돌입. 클라이언트 FIN_WAIT_2 상태 돌입.
서버가 ACK 승인 세그먼트 송신 후 일정 시간 이후 클라이언트에 FIN 세그먼트 송신.
클라이언트 TIME_WAIT 상태 돌입. 서버로 ACK 송신. 서버 CLOSED 상태 돌입. 클라이언트 일정 시간 대기 후 연결 종료 및 양측 자원 연결 해제. 지연 패킷 발생의 경우 대비 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제 발생 두 장치가 연결이 닫혔는지 확인 LAST_ACK 상태에서 닫히게 되면 새로운 연결 시도 시 LAST_ACK 상태이기 때문에 접속 오류 발생 즉, 네트워크 환경의 불확실성을 처리하는 역할을 함.순서를 보장하지 않고 수신 여부를 확인하지 않음.<br>
<a data-tooltip-position="top" aria-label="TCP／IP 4계층 > 전송 계층 > UDP > 데이터그램 패킷 교환 방식" data-href="TCP／IP 4계층#전송 계층#UDP#데이터그램 패킷 교환 방식" href="1.-cs/네트워크/tcp／ip-4계층.html#전송_계층_0" class="internal-link" target="_self" rel="noopener nofollow">데이터그램 패킷 교환 방식</a>데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.
이를&nbsp;데이터그램이라 한다.
패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있으며(비연결 지향형) 도착 순서 또한 다를 수 있다.Internet Layer
장치로부터 받은 네트워크 패킷을 IP주소로 지정된 호스트로 전송하기 위한 계층패킷을 수신해야할 상대의 주소를 지정하여 데이터를 전달
상대방이 제대로 받았는지에 대해 보장하지 않음(비연결형적)Internet Protocol
데이터 패킷이 목적지까지 정확하게 도달할 수 있도록 주소(IP 주소) 를 부여하고 경로를 설정하는 가장 기본적인 프로토콜Address Resolution Protocol
논리적인 IP 주소를 실제 통신에 필요한 물리적인 MAC 주소로 변환해 주는 프로토콜입니다.Internet Control Message Protocol
IP 통신 중에 발생하는 오류 상황을 알려주거나 네트워크 상태를 진단하기 위해 사용하는 관리용 프로토콜입니다.Network Interface Layer
실질적으로 데이터를 전달하며 장치 간에 신호를 주고 받는 규칙을 정하는 계층Full Duplex
양쪽 장치가 동시에 송수신할 수 있는 방식.
송신로와 수신로를 나누어 데이터를 주고 받음. (2차로)
유선 LAN(IEEE802.3)Half Duplex
양쪽 장치는 서로 통신할 수 있지만, 동시 통신은 불가능.(1차로)
무선 LAN(IEEE802.11)Carrier Sense Multiple Access with Collision Detection
데이터를 보낸 이후 충돌이 발생한다면 일정 시간 이후 재전송하는 방식Carrier Sense Multiple Access with Collision Avoidance
장치에서 데이터를 보내기 전에 일련의 관정을 기반으로 사전에 가능한 충돌 방지 방식Ethernet Frame
이더넷 기반의 네트워크에서 데이터를 전송할 때 사용되는 기본 단위
컴퓨터와 네트워크 장치 간에 정보를 교환하기 위해 사용되며, 이더넷 프레임은 표준화된 구조를 가지고 있어 서로 다른 장치들 간의 데이터 전송을 원활하게 함.<br><img alt="이더넷_프레임.png" src="99.-이미지/cs/이더넷_프레임.png" target="_self" style="width: 450px; max-width: 100%;">
Preamble : 이더넷 프레임이 시작임을 알림
SFD(Start Frame Delimiter) : 다음 바이트부터 MAC 주소 필드임을 알림
DMAC : 수신 MAC 주소
SMAC : 송신 MAC 주소
EtherType : IP 프로토콜 정의 IPv4 or IPv6
Payload : 전달 받은 데이터
CRC : 에러 확인 비트
<br><img alt="네트워크_과정_4계층.png" src="99.-이미지/cs/네트워크_과정_4계층.png" target="_self" style="width: 450px; max-width: 100%;">
애플리케이션 계층에서 전송 계층으로 Request 값들이 캡슐화 과정을 거쳐 전달
링크(네트워크 인터페이스) 계층을 통해 서버와 통신
서버의 링크 계층으로부터 애플리케이션까지 비캡슐화
컴퓨터 내부의 통신 프로토콜 제어(연결 수립, 흐름 제어 등)를 위한 패킷들은 대부분 L4(전송 계층) 이하에서 OS에 의해 처리되고 종료됨.사용자가 체감하는 프로그램까지 데이터가 전달되는 것은 오직 그 안에 '사용자 데이터'가 들어있을 때, 헤더를 제거한 뒤에 처리해야 할 페이로드가 남아있는 경우에만 상위 계층으로 이동통신의 목적에 따라 시작점과 종점이 변경된다.상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입<br><img alt="네트워크_4계층_캡슐화.png" src="99.-이미지/cs/네트워크_4계층_캡슐화.png" target="_self" style="width: 450px; max-width: 100%;">
세그먼트(또는 데이터그램)화 : TCP(L4) 헤더 추가
패킷화 : IP(L3) 헤더 추가
프레임화 : 프레임 헤더, 트레일러 추가
하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정<br><img alt="네트워크_4계층_비캡슐화.png" src="99.-이미지/cs/네트워크_4계층_비캡슐화.png" target="_self" style="width: 450px; max-width: 100%;">
프레임의 패킷화
패킷의 세그먼트(또는 데이터그램)화
메시지화
Protocol Data Unit
계층으로 데이터가 전달될 때 덩어리의 단위.
헤더(Header) : 제어 관련 정보
페이로드(Payload) : 데이터
각 계층 별로 부르는 명칭이 상이함.
애플리케이션 계층 : 메시지
전송 계층 : 세그먼트(TCP), 데이터그램(UDP)
인터넷 계층 : 패킷
링크(네트워크 인터페이스) 계층 : 프레임(데이터 링크 계층), 비트(물리 계층)
]]></description><link>1.-cs/네트워크/tcp／ip-4계층.html</link><guid isPermaLink="false">1. CS/네트워크/TCP／IP 4계층.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[선언형 프로그래밍]]></title><description><![CDATA[Declarative Programming
'무엇을' 풀어내는가에 집중하는 패러다임.
"프로그램은 한수로 이루어진 것이다." 라는 명제가 담겨 있는 패러다임
순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임.순수 함수 : 출력이 입력에만 의존하는 함수
고차 함수 : 매개변수로 함수를 받아 로직을 생성하는 함수. 고차 함수를 사용하기 위해서는 사용 언어가 일급 객체라는 특징을 가져야함.
일급 객체: 변수나 메서드에 함수 할당 가능
함수 안에 함수를 매개 변수로 할당 가능
함수가 함수를 반환 가능
커링 : <a href=".?query=tag:TODO" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#TODO">#TODO</a><br>
불변성 : <a href=".?query=tag:TODO" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#TODO">#TODO</a>]]></description><link>1.-cs/프로그래밍-패러다임/선언형-프로그래밍.html</link><guid isPermaLink="false">1. CS/프로그래밍 패러다임/선언형 프로그래밍.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[HTTP]]></title><description><![CDATA[한 연결당 하나의 요청을 처리
-&gt; RTT의 증가RTT
Round Trip time
패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간
서버로부터 파일을 가져올 때마다 TCP의 <a data-tooltip-position="top" aria-label="TCP／IP 4계층 > TCP > TCP 연결 성립 과정" data-href="TCP／IP 4계층#TCP#TCP 연결 성립 과정" href="1.-cs/네트워크/tcp／ip-4계층.html#TCP" class="internal-link" target="_self" rel="noopener nofollow">3-way handshake</a>를 계속해서 열어야함.
-&gt; RTT 증가이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩 등을 활용해 해결이미지 스플리팅
많은 이미지를 다운로드 받게 되면 과부하가 걸리기 때문에 많은 이미지가 합쳐 있는 하나의 이미지를 다운로드 받고 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법
코드 압축
코드의 개행 문자, 빈칸을 없애서 코드의 크기를 최소화하는 방법
이미지 base64 인코딩
이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법.
매번 TCP 연결을 하는 것이 아닌 한번 TCP 초기화를 한 이후 keep-alive 옵션을 통해 여러 개의 파일을 송수신할 수 있게 수정
1.0에서 존재 했지만 1.1부터 표준화 및 기본 옵션으로 지정됨.<br><img alt="keep_alive.png" src="99.-이미지/cs/keep_alive.png" target="_self" style="width: 450px; max-width: 100%;"><br>처음 TCP <a data-tooltip-position="top" aria-label="TCP／IP 4계층 > TCP > TCP 연결 성립 과정" data-href="TCP／IP 4계층#TCP#TCP 연결 성립 과정" href="1.-cs/네트워크/tcp／ip-4계층.html#TCP" class="internal-link" target="_self" rel="noopener nofollow">3-way handshake</a>가 발생하면 이후 요청에도 발생하지 않음.
문서 안에 포함된 리소스 개수에 비례한 대기 시간 증가는 여전함.헤더에 많은 메타데이터가 있지만 압축되지 않아 상대적으로 무거움Head of Line Blocking
네트워크에서 같은 큐에 있는 패킷이 처음 패킷에 의해 지연될 때 발생하는 성능 저하 현상SPDY 프로토콜에서 파생된 HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티 플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원 프로토콜Multiplexing
여러 개의 스트림을 사용하여 송수신하는 기법특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미침.스트림(stream)
시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
허프만 코딩 압축 알고리즘을 활용하여 HPACK 압축 형식을 통해 HTTP/1.x의 큰 헤더 문제를 해결허프만 코딩(Huffman Coding)
문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 기법
HTTP/2의 경우 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있음.
ex) html을 읽으며 포함되어 있는 css 및 js 파일을 서버에서 푸시하는 경우애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰 가능 HTTP 요청
이를 통해 통신을 암호화함.SSL : Secure Socket Layer
TLS : Transport Layer Security Protocol전송 계층에서 보안을 제공하는 프로토콜. 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록함.보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용됨.보안이 시작되고 끝나는 동안 유지되는 세션. SSL/TLS는 HandShake를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보를 공유운영체제가 사용자로부터 자신의 자산 이용을 허락하는 일정 기간CA(Certificate Authorities)에서 발급한 인증서를 기반으로 공개키를 클라이언트에 제공하고 서버가 신뢰할 수 있는 서버를 보장함. 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어짐.QUIC 계층 위에서 돌아가는 UDP 기반의 HTTPQuick UDP Internet Connection<br>TCP를 사용하는 것이 아닌 UDP를 사용하기 때문에 <a data-tooltip-position="top" aria-label="TCP／IP 4계층 > 전송 계층 > TCP 연결 성립 과정" data-href="TCP／IP 4계층#전송 계층#TCP 연결 성립 과정" href="1.-cs/네트워크/tcp／ip-4계층.html#전송 계층" class="internal-link" target="_self" rel="noopener nofollow">3-way handshake</a> 과정을 저치지 않아도 되기 때문에 첫 연결 설정에 1-RTT만 소요됨.전송 패킷이 손실된 경우 수신 측에서 에러를 검출하고 수정하는 방식인 순방향 오류 수정 메커니즘(FEC, Forword Error Correction) 이 적용됨.]]></description><link>1.-cs/네트워크/http.html</link><guid isPermaLink="false">1. CS/네트워크/HTTP.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로그래밍 패러다임]]></title><description><![CDATA[Programming Paradigm
프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
프로그래밍 패러다임
<a data-tooltip-position="top" aria-label="선언형 프로그래밍" data-href="선언형 프로그래밍" href="1.-cs/프로그래밍-패러다임/선언형-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">|선언형</a> <br><a data-tooltip-position="top" aria-label="선언형 프로그래밍 > 함수형 프로그래밍" data-href="선언형 프로그래밍#함수형 프로그래밍" href="1.-cs/프로그래밍-패러다임/선언형-프로그래밍.html#함수형 프로그래밍" class="internal-link" target="_self" rel="noopener nofollow">|함수형</a> 명형형 <br><a data-tooltip-position="top" aria-label="객체지향 프로그래밍" data-href="객체지향 프로그래밍" href="1.-cs/프로그래밍-패러다임/객체지향-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">|객체지향형</a>
<br><a data-tooltip-position="top" aria-label="절차지향 프로그래밍" data-href="절차지향 프로그래밍" href="1.-cs/프로그래밍-패러다임/절차지향-프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">|절차지향형</a> 프로그래밍 기법, 개발 방법론의 정답은 없다.
비즈니스 로직 및 서비스 특징을 고려해 패러다임을 결정하는 것이 중요.]]></description><link>1.-cs/프로그래밍-패러다임.html</link><guid isPermaLink="false">1. CS/프로그래밍 패러다임.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[네트워크]]></title><description><![CDATA[
컴퓨터 등의 장치들이 통신 기술을 이용하여 구축하는 연결망
노드(node) + 링크(link)로 연결되어 있으며, 리소스를 공유하는 집합
노드 : 서버, 라우터, 스위치 등 네트워크 장비
링크 : 유선 또는 무선좋은 네트워크란 많은 <a data-tooltip-position="top" aria-label="처리량과 지연 시간 > 처리량" data-href="처리량과 지연 시간#처리량" href="1.-cs/네트워크/처리량과-지연-시간.html#처리량" class="internal-link" target="_self" rel="noopener nofollow">처리량</a>을 처리할 수 있으며 <a data-tooltip-position="top" aria-label="처리량과 지연 시간 > 지연 시간" data-href="처리량과 지연 시간#지연 시간" href="1.-cs/네트워크/처리량과-지연-시간.html#지연 시간" class="internal-link" target="_self" rel="noopener nofollow">지연 시간</a>이 짧고 장애 빈도가 적은 네트워크<br><a data-href="네트워크 분류" href="1.-cs/네트워크/네트워크-분류.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 분류</a><br><a data-href="네트워크 토폴로지" href="1.-cs/네트워크/네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 토폴로지</a><br><a data-href="네트워크 성능 분석 명령어" href="1.-cs/네트워크/네트워크-성능-분석-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 성능 분석 명령어</a><br><a data-href="네트워크 기기" href="1.-cs/네트워크/네트워크-기기.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 기기</a><br><a data-href="IP 주소 체계" href="1.-cs/네트워크/ip-주소-체계.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소 체계</a><br><a data-href="ARP" href="1.-cs/네트워크/arp.html" class="internal-link" target="_self" rel="noopener nofollow">ARP</a><br><a data-href="홉바이홉 통신" href="1.-cs/네트워크/홉바이홉-통신.html" class="internal-link" target="_self" rel="noopener nofollow">홉바이홉 통신</a>
Internet Protocol Suite
인터넷에서 컴퓨터들이 서로 정보를 주고 받는 데 사용되는 프로토콜의 집합
<br>일반적으로 <a data-href="TCP／IP 4계층" href="1.-cs/네트워크/tcp／ip-4계층.html" class="internal-link" target="_self" rel="noopener nofollow">TCP／IP 4계층</a> 모델이나 <a data-href="OSI 7계층" href="1.-cs/네트워크/osi-7계층.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 7계층</a> 모델로 설명한다.]]></description><link>1.-cs/네트워크.html</link><guid isPermaLink="false">1. CS/네트워크.md</guid><pubDate>Sun, 18 Jan 2026 20:38:39 GMT</pubDate></item><item><title><![CDATA[자료구조_힙]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_힙.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_힙.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_힙.png</guid><pubDate>Thu, 15 Jan 2026 07:16:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_AVL트리_RL]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_avl트리_rl.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_avl트리_rl.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_AVL트리_RL.png</guid><pubDate>Wed, 14 Jan 2026 13:55:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_AVL트리_LR]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_avl트리_lr.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_avl트리_lr.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_AVL트리_LR.png</guid><pubDate>Wed, 14 Jan 2026 13:53:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_AVL트리_RR]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_avl트리_rr.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_avl트리_rr.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_AVL트리_RR.png</guid><pubDate>Wed, 14 Jan 2026 13:51:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_AVL트리_LL]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_avl트리_ll.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_avl트리_ll.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_AVL트리_LL.png</guid><pubDate>Wed, 14 Jan 2026 13:50:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_AVL트리]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_avl트리.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_avl트리.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_AVL트리.png</guid><pubDate>Wed, 14 Jan 2026 13:42:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_이진탐색트리]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_이진탐색트리.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_이진탐색트리.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_이진탐색트리.png</guid><pubDate>Wed, 14 Jan 2026 00:09:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_이진트리]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_이진트리.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_이진트리.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_이진트리.png</guid><pubDate>Tue, 13 Jan 2026 23:55:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_트리_요소]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_트리_요소.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_트리_요소.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_트리_요소.png</guid><pubDate>Tue, 13 Jan 2026 23:21:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_트리]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_트리.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_트리.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_트리.png</guid><pubDate>Tue, 13 Jan 2026 23:04:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자료구조_그래프]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_그래프.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_그래프.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_그래프.png</guid><pubDate>Tue, 13 Jan 2026 22:52:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[정렬]]></title><link>1.-cs/알고리즘/정렬.html</link><guid isPermaLink="false">1. CS/알고리즘/정렬.md</guid><pubDate>Sun, 11 Jan 2026 04:57:39 GMT</pubDate></item><item><title><![CDATA[자료구조_연결리스트]]></title><description><![CDATA[<img src="99.-이미지/cs/자료구조_연결리스트.png" target="_self">]]></description><link>99.-이미지/cs/자료구조_연결리스트.html</link><guid isPermaLink="false">99. 이미지/CS/자료구조_연결리스트.png</guid><pubDate>Sun, 11 Jan 2026 04:51:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[격리성]]></title><description><![CDATA[<img src="99.-이미지/cs/격리성.png" target="_self">]]></description><link>99.-이미지/cs/격리성.html</link><guid isPermaLink="false">99. 이미지/CS/격리성.png</guid><pubDate>Sun, 11 Jan 2026 03:32:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_보이스코드정규화]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_보이스코드정규화.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_보이스코드정규화.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_보이스코드정규화.png</guid><pubDate>Sun, 11 Jan 2026 02:26:31 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_제3정규형]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_제3정규형.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_제3정규형.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_제3정규형.png</guid><pubDate>Sun, 11 Jan 2026 02:19:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_제2정규형]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_제2정규형.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_제2정규형.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_제2정규형.png</guid><pubDate>Sun, 11 Jan 2026 02:15:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_제1정규화]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_제1정규화.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_제1정규화.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_제1정규화.png</guid><pubDate>Sun, 11 Jan 2026 02:12:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_키]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_키.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_키.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_키.png</guid><pubDate>Sun, 11 Jan 2026 01:51:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_N대M]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_n대m.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_n대m.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_N대M.png</guid><pubDate>Sun, 11 Jan 2026 01:49:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_1대N]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_1대n.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_1대n.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_1대N.png</guid><pubDate>Sun, 11 Jan 2026 01:49:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_1대1]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_1대1.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_1대1.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_1대1.png</guid><pubDate>Sun, 11 Jan 2026 01:49:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터베이스_용어]]></title><description><![CDATA[<img src="99.-이미지/cs/데이터베이스_용어.png" target="_self">]]></description><link>99.-이미지/cs/데이터베이스_용어.html</link><guid isPermaLink="false">99. 이미지/CS/데이터베이스_용어.png</guid><pubDate>Sun, 11 Jan 2026 01:46:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[다단계_큐]]></title><description><![CDATA[<img src="99.-이미지/cs/다단계_큐.png" target="_self">]]></description><link>99.-이미지/cs/다단계_큐.html</link><guid isPermaLink="false">99. 이미지/CS/다단계_큐.png</guid><pubDate>Sun, 11 Jan 2026 00:47:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[모니터]]></title><description><![CDATA[<img src="99.-이미지/cs/모니터.png" target="_self">]]></description><link>99.-이미지/cs/모니터.html</link><guid isPermaLink="false">99. 이미지/CS/모니터.png</guid><pubDate>Sat, 10 Jan 2026 23:51:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[세마포어]]></title><description><![CDATA[<img src="99.-이미지/cs/세마포어.png" target="_self">]]></description><link>99.-이미지/cs/세마포어.html</link><guid isPermaLink="false">99. 이미지/CS/세마포어.png</guid><pubDate>Sat, 10 Jan 2026 23:28:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[뮤텍스]]></title><description><![CDATA[<img src="99.-이미지/cs/뮤텍스.png" target="_self">]]></description><link>99.-이미지/cs/뮤텍스.html</link><guid isPermaLink="false">99. 이미지/CS/뮤텍스.png</guid><pubDate>Sat, 10 Jan 2026 23:21:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스레드_공유자원]]></title><description><![CDATA[<img src="99.-이미지/cs/스레드_공유자원.png" target="_self">]]></description><link>99.-이미지/cs/스레드_공유자원.html</link><guid isPermaLink="false">99. 이미지/CS/스레드_공유자원.png</guid><pubDate>Wed, 07 Jan 2026 09:23:43 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[명명파이프]]></title><description><![CDATA[<img src="99.-이미지/cs/명명파이프.png" target="_self">]]></description><link>99.-이미지/cs/명명파이프.html</link><guid isPermaLink="false">99. 이미지/CS/명명파이프.png</guid><pubDate>Wed, 07 Jan 2026 09:13:30 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[컨텍스트_스위칭]]></title><description><![CDATA[<img src="99.-이미지/cs/컨텍스트_스위칭.png" target="_self">]]></description><link>99.-이미지/cs/컨텍스트_스위칭.html</link><guid isPermaLink="false">99. 이미지/CS/컨텍스트_스위칭.png</guid><pubDate>Wed, 07 Jan 2026 08:22:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로세스_메모리_구조]]></title><description><![CDATA[<img src="99.-이미지/cs/프로세스_메모리_구조.png" target="_self">]]></description><link>99.-이미지/cs/프로세스_메모리_구조.html</link><guid isPermaLink="false">99. 이미지/CS/프로세스_메모리_구조.png</guid><pubDate>Wed, 07 Jan 2026 07:44:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로세스상태]]></title><description><![CDATA[<img src="99.-이미지/cs/프로세스상태.png" target="_self">]]></description><link>99.-이미지/cs/프로세스상태.html</link><guid isPermaLink="false">99. 이미지/CS/프로세스상태.png</guid><pubDate>Wed, 07 Jan 2026 07:30:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[컴파일과정]]></title><description><![CDATA[<img src="99.-이미지/cs/컴파일과정.png" target="_self">]]></description><link>99.-이미지/cs/컴파일과정.html</link><guid isPermaLink="false">99. 이미지/CS/컴파일과정.png</guid><pubDate>Wed, 07 Jan 2026 07:21:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[페이지알고리즘]]></title><description><![CDATA[<img src="99.-이미지/cs/페이지알고리즘.png" target="_self">]]></description><link>99.-이미지/cs/페이지알고리즘.html</link><guid isPermaLink="false">99. 이미지/CS/페이지알고리즘.png</guid><pubDate>Wed, 07 Jan 2026 07:08:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[가상메모리]]></title><description><![CDATA[<img src="99.-이미지/cs/가상메모리.png" target="_self">]]></description><link>99.-이미지/cs/가상메모리.html</link><guid isPermaLink="false">99. 이미지/CS/가상메모리.png</guid><pubDate>Wed, 07 Jan 2026 06:12:09 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Redis]]></title><description><![CDATA[<img src="99.-이미지/cs/redis.png" target="_self">]]></description><link>99.-이미지/cs/redis.html</link><guid isPermaLink="false">99. 이미지/CS/Redis.png</guid><pubDate>Wed, 07 Jan 2026 06:08:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[캐시히트미스]]></title><description><![CDATA[<img src="99.-이미지/cs/캐시히트미스.png" target="_self">]]></description><link>99.-이미지/cs/캐시히트미스.html</link><guid isPermaLink="false">99. 이미지/CS/캐시히트미스.png</guid><pubDate>Wed, 07 Jan 2026 05:56:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[메모리계층]]></title><description><![CDATA[<img src="99.-이미지/cs/메모리계층.png" target="_self">]]></description><link>99.-이미지/cs/메모리계층.html</link><guid isPermaLink="false">99. 이미지/CS/메모리계층.png</guid><pubDate>Wed, 07 Jan 2026 05:27:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[modebit]]></title><description><![CDATA[<img src="99.-이미지/cs/modebit.png" target="_self">]]></description><link>99.-이미지/cs/modebit.html</link><guid isPermaLink="false">99. 이미지/CS/modebit.png</guid><pubDate>Wed, 07 Jan 2026 04:50:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[시스템콜2]]></title><description><![CDATA[<img src="99.-이미지/cs/시스템콜2.png" target="_self">]]></description><link>99.-이미지/cs/시스템콜2.html</link><guid isPermaLink="false">99. 이미지/CS/시스템콜2.png</guid><pubDate>Wed, 07 Jan 2026 04:47:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[시스템콜1]]></title><description><![CDATA[<img src="99.-이미지/cs/시스템콜1.png" target="_self">]]></description><link>99.-이미지/cs/시스템콜1.html</link><guid isPermaLink="false">99. 이미지/CS/시스템콜1.png</guid><pubDate>Wed, 07 Jan 2026 04:41:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OS구조]]></title><description><![CDATA[<img src="99.-이미지/cs/os구조.png" target="_self">]]></description><link>99.-이미지/cs/os구조.html</link><guid isPermaLink="false">99. 이미지/CS/OS구조.png</guid><pubDate>Wed, 07 Jan 2026 04:36:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[keep_alive]]></title><description><![CDATA[<img src="99.-이미지/cs/keep_alive.png" target="_self">]]></description><link>99.-이미지/cs/keep_alive.html</link><guid isPermaLink="false">99. 이미지/CS/keep_alive.png</guid><pubDate>Tue, 06 Jan 2026 08:37:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[클래스기반_IP할당]]></title><description><![CDATA[<img src="99.-이미지/cs/클래스기반_ip할당.png" target="_self">]]></description><link>99.-이미지/cs/클래스기반_ip할당.html</link><guid isPermaLink="false">99. 이미지/CS/클래스기반_IP할당.png</guid><pubDate>Tue, 06 Jan 2026 06:24:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크_4계층_비캡슐화]]></title><description><![CDATA[<img src="99.-이미지/cs/네트워크_4계층_비캡슐화.png" target="_self">]]></description><link>99.-이미지/cs/네트워크_4계층_비캡슐화.html</link><guid isPermaLink="false">99. 이미지/CS/네트워크_4계층_비캡슐화.png</guid><pubDate>Tue, 06 Jan 2026 05:10:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크_4계층_캡슐화]]></title><description><![CDATA[<img src="99.-이미지/cs/네트워크_4계층_캡슐화.png" target="_self">]]></description><link>99.-이미지/cs/네트워크_4계층_캡슐화.html</link><guid isPermaLink="false">99. 이미지/CS/네트워크_4계층_캡슐화.png</guid><pubDate>Tue, 06 Jan 2026 05:08:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크_과정_4계층]]></title><description><![CDATA[<img src="99.-이미지/cs/네트워크_과정_4계층.png" target="_self">]]></description><link>99.-이미지/cs/네트워크_과정_4계층.html</link><guid isPermaLink="false">99. 이미지/CS/네트워크_과정_4계층.png</guid><pubDate>Tue, 06 Jan 2026 05:04:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이더넷_프레임]]></title><description><![CDATA[<img src="99.-이미지/cs/이더넷_프레임.png" target="_self">]]></description><link>99.-이미지/cs/이더넷_프레임.html</link><guid isPermaLink="false">99. 이미지/CS/이더넷_프레임.png</guid><pubDate>Tue, 06 Jan 2026 04:54:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4way_handshake]]></title><description><![CDATA[<img src="99.-이미지/cs/4way_handshake.png" target="_self">]]></description><link>99.-이미지/cs/4way_handshake.html</link><guid isPermaLink="false">99. 이미지/CS/4way_handshake.png</guid><pubDate>Tue, 06 Jan 2026 04:15:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3way_handshake]]></title><description><![CDATA[<img src="99.-이미지/cs/3way_handshake.png" target="_self">]]></description><link>99.-이미지/cs/3way_handshake.html</link><guid isPermaLink="false">99. 이미지/CS/3way_handshake.png</guid><pubDate>Tue, 06 Jan 2026 04:14:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크_과정]]></title><description><![CDATA[<img src="99.-이미지/cs/네트워크_과정.png" target="_self">]]></description><link>99.-이미지/cs/네트워크_과정.html</link><guid isPermaLink="false">99. 이미지/CS/네트워크_과정.png</guid><pubDate>Mon, 05 Jan 2026 22:46:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크_계층]]></title><description><![CDATA[<img src="99.-이미지/cs/네트워크_계층.png" target="_self">]]></description><link>99.-이미지/cs/네트워크_계층.html</link><guid isPermaLink="false">99. 이미지/CS/네트워크_계층.png</guid><pubDate>Mon, 05 Jan 2026 22:45:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스푸핑]]></title><description><![CDATA[<img src="99.-이미지/cs/스푸핑.png" target="_self">]]></description><link>99.-이미지/cs/스푸핑.html</link><guid isPermaLink="false">99. 이미지/CS/스푸핑.png</guid><pubDate>Mon, 05 Jan 2026 21:25:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[처리량]]></title><description><![CDATA[<img src="99.-이미지/cs/처리량.png" target="_self">]]></description><link>99.-이미지/cs/처리량.html</link><guid isPermaLink="false">99. 이미지/CS/처리량.png</guid><pubDate>Mon, 05 Jan 2026 21:08:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[분산_시스템_예시]]></title><description><![CDATA[<img src="99.-이미지/cs/분산_시스템_예시.png" target="_self">]]></description><link>99.-이미지/cs/분산_시스템_예시.html</link><guid isPermaLink="false">99. 이미지/CS/분산_시스템_예시.png</guid><pubDate>Thu, 16 Oct 2025 07:45:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tech_note]]></title><description><![CDATA[Tuan(이정훈)이 작성한 개발 관련 지식 아카이브입니다.CS(Computer Science), Mobile 관련이 주를 이룹니다.
Architecture, Back-End 관련 내용도 추후 천천히 업로드 예정입니다.아직 정보 인덱스 관리가 미흡합니다.
원하는 정보를 찾는 경우 검색 또는 목차에서 탐색 부탁드립니다.CS
Android
Document<a data-tooltip-position="top" aria-label="mailto:jhmh0226@gmail.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:jhmh0226@gmail.com" target="_self">jhmh0226@gmail.com</a>
오류 관련 지적 환영합니다.]]></description><link>tech_note.html</link><guid isPermaLink="false">Tech_note.md</guid><pubDate>Sun, 18 Jan 2026 21:11:40 GMT</pubDate></item></channel></rss>